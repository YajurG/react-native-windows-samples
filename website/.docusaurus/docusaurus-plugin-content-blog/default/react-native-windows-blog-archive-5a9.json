{
  "blogPosts": [
    {
      "id": "/2022/07/29/coreapp",
      "metadata": {
        "permalink": "/react-native-windows/blog/2022/07/29/coreapp",
        "source": "@site/blog/2022-07-29-coreapp.md",
        "title": "Streamlining app creation with React Native for Windows CoreApp",
        "description": "Streamlining app creation with React Native for Windows CoreApp",
        "date": "2022-07-29T00:00:00.000Z",
        "formattedDate": "July 29, 2022",
        "tags": [],
        "readingTime": 5.625,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Alexander Sklar",
            "url": "https://twitter.com/alexsklar"
          }
        ],
        "frontMatter": {
          "title": "Streamlining app creation with React Native for Windows CoreApp",
          "author": "Alexander Sklar",
          "authorURL": "https://twitter.com/alexsklar",
          "description": "Streamlining app creation with React Native for Windows CoreApp",
          "is_blog": true,
          "published_date": "July 29, 2022"
        },
        "nextItem": {
          "title": "Calling Windows APIs from React Native just got easier",
          "permalink": "/react-native-windows/blog/2022/02/11/rnwinrt"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/steamline-coreapp-windows/\" />\n</head>\n\nReact Native builds on top of the native platform for every OS it runs on; on Windows, this translates to producing a Universal Windows Platform (UWP) app.\n\nWe heard from some of our customers that build times for these types of apps can be pretty long - especially so when building the React Native for Windows framework from source. To mitigate this problem we offer pre-built binary distributions of the framework in the form of NuGet packages. This works pretty well but has a few shortcomings: even when not building the framework itself, building a UWP app requires several build steps behind the scenes (the steps below are what happens for C++/WinRT apps):\n  - the MIDL compiler is run to turn IDL files into Windows Metadata - this is required to produce information used by the XAML compiler\n  - the XAML compiler is invoked to convert XAML markup files into C++ code\n  - the MDMerge tool runs to merge all Windows Metadata files from the application\n  - C++/WinRT is invoked to turn Windows Metadata into C++ projection headers as well as component sources\n  - Only then, the C++ compiler and linker run on the app\n\nWe set out to address this since a lot of applications won't need to customize their native code (e.g. by having XAML UI that isn't rendered by RNW); these _greenfield_ applications consist of the bare-bones native UWP app, and all of their app logic is confined to their JavaScript (and whatever native modules they require).\n\n## Enter `CoreApp`\nTo solve this issue, we came up with a very lean, yet flexible, API that enables a UWP Core Application (the kind that doesn't require XAML, or any interface definition) to host these _greenfield_ apps. We call this API `CoreApp`.\nWhen using the `CoreApp` API, the React Native for Windows framework provides the required `XamlApplication` object as well as a simple XAML `Page` object, which contains a React root view.\n\nThis is a new, _experimental_ C API that comes in two flavors:\n#### `RNCoreAppStart`\n```cpp\nvoid RNCoreAppStart(RNCoreAppCallback launched, void *data)\n```\n  This API starts a `CoreApp`, and upon launch, it will call your app back and pass some optional custom data to it as a parameter. The callback enables you to customize a number of parameters, like your bundle name, app name, etc. See CoreApp Schema below for more info. \n\n#### `RNCoreAppStartFromConfigJson`\n```cpp\nvoid RNCoreAppStartFromConfigJson(wchar_t const *configJson, \n      RNCoreAppCallback launched, \n      void *data)\n```\n  This API is similar to the previous one but it takes a path to a JSON configuration file. The callback is optional in this case, since more often than not, the configuration file will have all the necessary information.\n\nThe `launched` callback above gives you an output `RNCoreApp` structure, where you can set a number of parameters, as well as the `data` parameter that you passed in when you called the `CoreApp` API.\n\nThe contents of the `RNCoreApp` structure can be fully set via the JSON configuration file, so next we'll take a look at what is in this JSON configuration file.\n\n## `CoreApp` schema\n\nBelow are the properties you can set in your app.config.json, with their default values.\nThese properties correspond to properties on the ReactInstanceSettings type.\n```json\n{\n  \"jsBundleFile\": \"index.windows\",\n  \"bundleRootPath\": \"ms-appx:///Bundle/\",\n  \"componentName\": null, // Required, this is your App's component name\n  \"useWebDebugger\": true,\n  \"useFastRefresh\": true,\n  \"useDeveloperSupport\": true,\n  \"useDirectDebugger\": false,\n  \"requestInlineSourceMap\": true,\n  \"enableDefaultCrashHandler\": false,\n  \"debuggerPort\": 9229,\n  \"sourceBundlePort\": 8081,\n  \"sourceBundleHost\": \"localhost\",\n  \"jsEngine\": \"chakra\", // possible values: \"chakra\", \"hermes\"\n  \"viewName\": null, // adds an optional title to the window\n  \"nativeModules\": [\n    {\n      // this corresponds to the DLL that hosts the native module,\n      // or the name of the app's exe (or null) if the module is locally defined\n      \"moduleContainer\": null,  \n\n      // the name of the factory function to call to produce a ReactPackageProvider for\n      // the module; see Using native modules below.\n      \"factory\": null,  \n      \n    }\n  ],\n  \"properties\": { \n    // these are all optional. They correspond to properties that will get set in the\n    // ReactPropertyBag for the instance. Some examples:\n    \"someString\": \"string value\",\n    \"someNumber\": 42.5,\n    \"someBoolean\": true,\n    \"namespace1.namespace2.foo\": 22\n  }\n}\n```\n\nFor building in Debug mode, your app will usually only need to set a few properties: `componentName`, and the native modules it uses.\n\n## Using native modules\nThere are a couple of ways that a `CoreApp` can load native modules.\n\nThe simplest way is using the `RNCoreAppStartFromConfigJson` API. As we saw above, this API allows us to pass an optional DLL name to load and a plain C function to call in that DLL, to produce the `ReactPackageProvider` for the module.\nHere's what this function would look like:\n\n```cpp\nextern \"C\" __declspec(dllexport) void *__cdecl MySpecialPackageProvider() {\n  auto provider = winrt::make<MyModulePackageProvider>();\n  void *abi{nullptr};\n  winrt::copy_to_abi(provider, abi);\n  return abi;\n}\n```\n\nThis snippet will declare a plain C function (this is important so that C++ name mangling mechanism doesn't come into play, which is required to be able to use the function name in the JSON file), and export it from the DLL (or the application's EXE). It takes no parameters, and simply return a pointer to the package provider for the module.\n\n\n\nIf using `RNCoreAppStart`, you can create each the `ReactPackageProvider` for each native module you use, and pass it in the `packageProvidersAbi` and `packageProvidersAbiCount` members of the `RNCoreApp` structure:\n\n```cpp\napp->packageProvidersAbiCount = 1;\napp->packageProvidersAbi =\n    reinterpret_cast<void **>(CoTaskMemAlloc(sizeof(void *) * app->packageProvidersAbiCount));\napp->packageProvidersAbi[0] = MySpecialPackageProvider();\n```\n\nwhere `MySpecialPackageProvider` is the same as above, only that the `extern \"C\" __declspec(dllexport)` part is not required since we don't care about the name, or exporting the function.\n\n## Get Started\nFor a sample, take a look at the Calculator CoreApp NuGet project in [/samples/CalculatorCoreAppNuGet](https://github.com/microsoft/react-native-windows-samples/tree/main/samples/CalculatorCoreAppNuGet).\n\n## Wrapping up\n\nWith the `RNCoreApp` approach - combined with NuGet distribution - we are seeing extremely fast native builds; builds that used to take 15-30 minutes now are down to 10-15 seconds. Because your application actually has very little native code to build, and all of the native logic is encapsulated for you in the React Native for Windows framework, you can get back to being productive in JavaScript, avoid hard-to-diagnose native code errors, and ship your app more quickly!\n\nCompare the calculator sample app (C++/WinRT, not using NuGet, not using CoreApp), takes almost 15 minutes to build:\n![Calculator build time from the pipeline](assets/2022-07-29-coreapp/Calculator.png)\n\nThe same app built using NuGet (but not CoreApp), slashes this to 3.5 minutes:\n![Calculator NuGet build time from the pipeline](assets/2022-07-29-coreapp/CalculatorNuGet.png)\n\nMeanwhile the CoreApp calculator sample clocks in at a speedy 1:49!\n![Calculator CoreApp NuGet build time from the pipeline](assets/2022-07-29-coreapp/CalculatorCoreAppNuGet.png)\n\nLook for this new API to make its debut in our 0.70 release, or try it today in our canary builds.\n\nIf you have any feedback, please don't hesitate to start a conversation on the [GitHub repo](https://github.com/microsoft/react-native-windows)!"
    },
    {
      "id": "/2022/02/11/rnwinrt",
      "metadata": {
        "permalink": "/react-native-windows/blog/2022/02/11/rnwinrt",
        "source": "@site/blog/2022-02-11-rnwinrt.md",
        "title": "Calling Windows APIs from React Native just got easier",
        "description": "Calling Windows APIs from React Native just got easier",
        "date": "2022-02-11T00:00:00.000Z",
        "formattedDate": "February 11, 2022",
        "tags": [],
        "readingTime": 6.595,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Angela Zhang",
            "url": "https://twitter.com/angelazhangg"
          }
        ],
        "frontMatter": {
          "title": "Calling Windows APIs from React Native just got easier",
          "author": "Angela Zhang",
          "authorURL": "https://twitter.com/angelazhangg",
          "description": "Calling Windows APIs from React Native just got easier",
          "is_blog": true,
          "published_date": "February 11, 2022"
        },
        "prevItem": {
          "title": "Streamlining app creation with React Native for Windows CoreApp",
          "permalink": "/react-native-windows/blog/2022/07/29/coreapp"
        },
        "nextItem": {
          "title": "React Native for Windows is helping Settings improve more quickly",
          "permalink": "/react-native-windows/blog/2022/02/11/settings"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/announcing-rnwinrt/\" />\n</head>\n\nWe are excited to announce the [React Native WinRT](http://aka.ms/reactnativewinrt) project, a new extension that makes it easier for [React Native for Windows](https://microsoft.github.io/react-native-windows/) developers to call Windows Runtime APIs directly from JavaScript! With React Native WinRT, developers can light up experiences that take advantage of unique platform features on Windows.\n\nIn this blog post, we will dive a little deeper into the technology, walk through some sample code, and show how React Native WinRT is already in use today.\n\nThe [React Native WinRT repo](https://github.com/microsoft/react-native-winrt) is now public, and a preview is available for developers to get started!\n\n<!--truncate-->\n\n## Introducing React Native WinRT (Preview)\n\nSince React Native for Windows apps are truly native, they have access to the underlying native Windows Runtime (WinRT) platform. In the past, developers needed to write a native module in C++ or C# to access these WinRT APIs. With React Native WinRT, it is now possible to **access the full set of Windows Runtime APIs directly from JavaScript** – no native code required!\n\nReact Native WinRT is a tool that takes a Windows Metadata (WinMD) file and produces a React Native turbo module from it, so WinRT APIs can be accessed from JavaScript or TypeScript. The tool itself is distributed as a NuGet package, [Microsoft.ReactNative.WinRT](https://www.nuget.org/packages/Microsoft.ReactNative.WinRT), and is available for any currently supported versions of React Native for Windows. As of this post, this includes support for versions 0.64 up to 0.67. React Native WinRT enables easier consumption of both public Windows platform APIs as well as existing 3rd party WinRT components. \n\nThe React Native WinRT project was motivated by our goal to make Windows development easier and more natural across various programming languages through language projections — other existing projects under the same umbrella include [C#/WinRT](http://aka.ms/cswinrt), [C++/WinRT](http://aka.ms/cppwinrt), and [Rust for Windows](https://docs.microsoft.com/windows/dev-environment/rust/rust-for-windows).\n\n\nThe React Native WinRT repo includes developer [usage documentation](https://github.com/microsoft/react-native-winrt/blob/main/docs/USAGE.md) and a [sample app](https://github.com/microsoft/react-native-winrt/tree/main/samples/RNWinRTTestApp) that showcases calling various WinRT APIs provided by the [Windows SDK](https://developer.microsoft.com/windows/downloads/windows-sdk/). The sample demonstrates how to incorporate Windows platform features such as push notifications, file storage, diagnostic logging, and jump list APIs into your React Native for Windows app. \n\n## Example: Adding Toast Notifications with React Native WinRT\n\nOne of the features the sample demonstrates is the Windows toast notification APIs. In a previous blog post, we showed how to [Add toast notifications to your React Native for Windows application](https://microsoft.github.io/react-native-windows/blog/2021/06/30/notifications). This involved writing a native module in C++ to call the native toast notification APIs and using the `JSValue` APIs to inspect values sent between the JavaScript side to the native module. Now with React Native WinRT, we can call the Toast notification APIs directly and naturally from JavaScript. Let’s walk through the steps to add toast notifications to your existing app. These steps are also in the developer usage documentation.\n\nFirst, download the WinRTTurboModule.zip file from the react-native-winrt [GitHub releases](https://github.com/microsoft/react-native-winrt/releases) page for the version of React Native for Windows version your app is using. When you unzip the file, you will see a directory containing the **WinRTTurboModule** project files and a file named `WinRTTurboModule.js`.\n\nCopy the **WinRTTurboModule** directory to your React Native for Windows application under the `windows` folder. Then, add the **WinRTTurboModule** project to your solution. We recommend using Visual Studio for these steps. Next, specify the WinRT namespaces you want to project using the `RnWinRTParameters` property in **ExperimentalFeatures.props**:\n```xml\n<PropertyGroup Label=\"React Native WinRT properties\">\n  <RnWinRTParameters>\n    -include Windows.UI.Notifications \n    -include Windows.Data.Xml.Dom\n  </RnWinRTParameters>\n</PropertyGroup>\n```\n\nNow you can build the **WinRTTurboModule** project to generate the React Native module containing these types. \n\nTo consume these types from your React Native Windows application, you will need to make the following modifications to reference the **WinRTTurboModule** project and load up the module:\n- Add a project reference from your React Native for Windows app to the **WinRTTurboModule** project.\n- Include the **WinRTTurboModule** header in your React Native for Windows app’s pch.h file:\n  ```cpp\n  #include <winrt/WinRTTurboModule.h>\n  ```\n- Register the module in your React Native for Windows app in App.cpp, inside the App constructor:\n  ```cpp\n  PackageProviders().Append(winrt::WinRTTurboModule::ReactPackageProvider());\n  ```\n- Load and initialize the module in your JavaScript code. Copy the **WinRTTurboModule.js** file from the downloaded zip file and place it under the main directory for your application (next to index.js):\n  ```javascript\n  import * as TurboModuleRegistry from 'react-native/Libraries/TurboModule/TurboModuleRegistry';\n  const module = TurboModuleRegistry.get('WinRTTurboModule');\n  if (module) {\n      module.initialize();\n  }\n  export default module;\n  ```\n\tThen, add the following import statement in your index.js file before the App import statement:\n\t```javascript\n\t\timport './WinRTTurboModule';\n\t\t…\n\t\timport App from './App';\n  ```\n\nAfter rebuilding and running your React Native for Windows app, you will now be able to call the Notifications and XML APIs directly from your JavaScript (or TypeScript) code. Below is an example of how to do so in your App.js file. \n\nFirst, implement the `showNotification` and `fillXmlElements` functions, which pops the toast notification and iterates through the key/value pairs for customizing the toast notification. \n\nIf you compare the code below to the [previous blog post](https://microsoft.github.io/react-native-windows/blog/2021/06/30/notifications) which implements toast notifications using native C++ code, you will notice that the implementation using React Native WinRT is now **entirely in JavaScript** and no longer requires any manual conversions of WinRT types.\n\t\n```javascript\nconst Notifications = Windows.UI.Notifications;\nconst ToastTemplateType = Notifications.ToastTemplateType;\nconst ToastNotificationManager = Notifications.ToastNotificationManager;\nconst ToastNotification = Notifications.ToastNotification;\n\nfunction showNotification(notification) {\n  var type = ToastTemplateType.toastText01;\n\n  var obj = {};\n  if (typeof(notification) == 'string') {\n    obj['text'] = notification;\n  } else {\n    obj = notification;\n  }\n\n  if (obj.template != undefined) {\n    type = obj.template;\n  }\n\n  var xml = ToastNotificationManager.getTemplateContent(type);\n  for (var tagName in obj) {\n    var xmlElements = xml.getElementsByTagName(tagName);\n    var value = obj[tagName];\n    if (typeof(value) == 'string') {\n      fillXmlElements(xml, xmlElements, [value]);\n    } else if (Array.isArray(value)) {\n      fillXmlElements(xml, xmlElements, value);\n    } else if (typeof(value) == 'object') {\n      fillXmlElements(xml, xmlElements, [value]);\n    }\n  }\n\n  var toast = new ToastNotification(xml);\n  ToastNotificationManager.createToastNotifier().show(toast);\n}\n\nfunction fillXmlElements(xml, xmlElements, arr) {\n  var i = 0;\n  for (var arrValue of arr) {\n    var node = xmlElements[i++];\n    if (typeof(arrValue) == 'string') {\n      node.appendChild(xml.createTextNode(arrValue));\n    } else if (typeof(arrValue) == 'object') {\n      for (var attrName in arrValue) {\n        var attr = node.attributes.getNamedItem(attrName);\n        if (!attr) {\n          attr = xml.createAttribute(attrName);\n          node.attributes.setNamedItem(attr);\n        }\n\n        attr.nodeValue = arrValue[attrName];\n      }\n    }\n  }\n}\n```\n\nNow that the functions have been implemented to parse and display a toast notification, you can add a UI component that calls the showNotification function. When specifying the template attribute, you can also now directly access the `ToastTemplateType` object in JavaScript.\n\n  ```jsx\n\timport {\n\t    Pressable,\n\t} from 'react-native';\n    // …\n      \t<Pressable onPress={() => {\n            \t\tshowNotification({\n              \t\ttemplate: Windows.UI.Notifications.ToastTemplateType.toastImageAndText01,\n              \t\ttext: \"hello world\",\n              \t\timage: {\n                \tsrc: \"https://microsoft.github.io/react-native-windows/img/header_logo.svg\",\n                \talt: \"React logo\",\n              \t\t}\n            \t\t});\n          \t}}>\n            \t<Text style={styles.sectionDescriptionButtonText}>Click to send a toast!</Text>\n      \t</Pressable> \n  ```\n\nYou can now build and run your React Native for Windows app to pop a toast notification! \n\n![A Windows toast notification triggered by a React Native for Windows app using React Native WinRT](assets/toast-rnwinrt.png)\n\nFor more details on the steps above, look at our [usage documentation](https://github.com/microsoft/react-native-winrt/blob/main/docs/USAGE.md).\n\n## React Native WinRT in action\nReact Native WinRT is already being used today — we have worked with the Settings and React Native for Windows teams to leverage this technology in building the new “Your Microsoft Account” page in the Windows 11 Settings app. Instead of needing to hand-author native modules in C++, the \"Your Microsoft Account” page takes advantage of React Native WinRT to optimize their implementation and access the full set of Windows Runtime APIs directly from JavaScript! \n\nTo read more about this new experience in Windows, check out the blog post on [React Native for Windows is helping Settings improve more quickly.](https://aka.ms/rnwsettingsblog).\n\n## Wrap-up\nGet started today by adding native Windows functionality to your React Native for Windows apps. Check out the React Native WinRT Github repo – we encourage you to try it out and give us your feedback.\n\nIf you’re interested in getting started with React Native for Windows, check out our website at [aka.ms/reactnative](https://aka.ms/reactnative). \n\nYou can also follow us on Twitter [@ReactNativeMSFT](https://twitter.com/reactnativemsft) to keep up to date on news, feature roadmaps, and more."
    },
    {
      "id": "/2022/02/11/settings",
      "metadata": {
        "permalink": "/react-native-windows/blog/2022/02/11/settings",
        "source": "@site/blog/2022-02-11-settings.md",
        "title": "React Native for Windows is helping Settings improve more quickly",
        "description": "React Native for Windows is helping Settings improve more quickly",
        "date": "2022-02-11T00:00:00.000Z",
        "formattedDate": "February 11, 2022",
        "tags": [],
        "readingTime": 4.63,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Steven Moyes, Alexander Sklar",
            "url": "https://twitter.com/ReactNativeMSFT"
          }
        ],
        "frontMatter": {
          "title": "React Native for Windows is helping Settings improve more quickly",
          "author": "Steven Moyes, Alexander Sklar",
          "authorURL": "https://twitter.com/ReactNativeMSFT",
          "description": "React Native for Windows is helping Settings improve more quickly",
          "is_blog": true,
          "published_date": "February 11, 2022"
        },
        "prevItem": {
          "title": "Calling Windows APIs from React Native just got easier",
          "permalink": "/react-native-windows/blog/2022/02/11/rnwinrt"
        },
        "nextItem": {
          "title": "Use Win32 features from a React Native for Windows application",
          "permalink": "/react-native-windows/blog/2021/08/05/win32component"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/rnw-settings-win11/\" />\n</head>\n\nReact Native isn’t just for mobile! Check out how the Windows 11 Settings app is leveraging React Native for Windows to deliver new features and capabilities to users faster and with the same great visual fidelity as Windows 11.\n\nIn this blog post, we discuss how and why Microsoft is using React Native for Windows to deliver the Your Microsoft Account page in Windows 11 Settings.\n\n<!--truncate-->\n\n![The \"Your Microsoft account\" page in Windows 11 Settings](assets/settings.png)\n\nWindows 11 [Insider Preview Build 22489](https://blogs.windows.com/windows-insider/2021/10/27/announcing-windows-11-insider-preview-build-22489/) debuted the **Your Microsoft account** Settings page, a re-imagined entry point in Settings that displays information related to your Microsoft account, including your subscriptions for Microsoft 365, links to order history, payment details, and Microsoft Rewards. \n\nThis page introduces a new mechanism that enables Windows to improve the **Your Microsoft account** page over time via [Online Service Experience Packs](https://blogs.windows.com/windows-insider/2021/10/27/announcing-windows-11-insider-preview-build-22489/); these are a way to make updates to Windows outside of major OS updates. This underlying infrastructure will enable other Windows 11 experiences to leverage the Online Service Experience Pack capability over time.\n\nReact Native for Windows is one of the key technologies used by Online Service Experience Packs to deliver the **Your Microsoft Account** page in Settings. Let’s dive into how and why Microsoft is using React Native for Windows to help the team be more productive and integrate seamlessly with the look and feel of the Windows 11 OS.\n\n## Introduction to the “Your Microsoft Account” page\nEnabling you to manage your account information directly from the Windows 11 Settings is one of the key goals for the new **Your Microsoft Account** page. Before Windows 11, your only option for managing these settings was to visit the [account.microsoft.com](https://account.microsoft.com) website (“AMC”). The team wanted to have a consistent set of functionality and user experience between the native and web versions and considered several options to accomplish this, including: \n1.  Maintain separate codebases (both the web front-end and a WinUI/native based front-end)\n1.  Host the AMC web content in a WebView control inside the Settings app\n1.  Use [React Native for Windows](https://microsoft.github.io/react-native-windows/) to share some code and have it render natively\n\nThe first option requires different codebases and is difficult to keep a consistent set of features between the two, especially as services iterate faster than the cadence at which Windows ships. Additionally, the team would need expertise in both web technology and native WinUI technology.  \n\nUsing a WebView reduces the upkeep cost; however, it suffers from a few problems. The visual appearance of controls would not fit in with the rest of the Windows 11 Settings app. Secondly, performance and accessibility of WebView UX tend not to be as good as a native equivalent. Lastly, interfacing between code running inside the WebView and the platform is cumbersome and limited.\n\nThis led us to the third option, which is using React Native for Windows in the Settings app. With React Native for Windows, you can use JavaScript to drive app logic, while sharing code across experiences.\n\nReact Native for Windows enables teams to be more productive by allowing them to quickly iterate on a change, without having to spend time rebuilding. Because it uses WinUI for rendering UI, it integrates seamlessly with the look and feel of the OS, with great performance, accessibility, and a rich set of features.\n\n## React Native for Windows + “Your Microsoft Account” page\nOne of the goals for the Your Microsoft Account page was to share business logic between the web and native platforms. React Native for Windows enables sharing core business logic while also enabling visual consistency between the web and native without needing to duplicate code. More importantly, the visual fidelity of the native experience is “authentically native” because _the page itself is native_, resulting in beautiful animations, accessibility, and the latest Windows 11 styles.\n\nBeyond the benefit to user experience, our team also experienced a set of developer productivity benefits as well. Developing with React Native increased our “dev inner loop” by providing features like fast refresh, which meant that changes to the JavaScript code could be seen instantly – with no app rebuild required. Additionally, through a custom hook implementation within the Windows Update service, we can safely and securely deliver JavaScript bundles to end users more quickly, whether it is a new feature or a fix for a critical issue.\n\nThe “Your Microsoft Account” page leverages the **React Native WinRT** extension to access the underlying native WinRT platform directly from JavaScript. To learn how you can take advantage of **React Native WinRT**, check out the companion blog post [“Calling Windows APIs from React Native just got easier”](https://aka.ms/rnwinrtblog).\n\nIf you would like to enable service delivery within your React Native application, check out [App Center CodePush for React Native](https://github.com/Microsoft/react-native-code-push), which is a solution for building, testing, distributing, and monitoring React Native apps. \n\n## Conclusion \n\nReact Native for Windows allows the Windows team to deliver new features to users faster and share business logic across web/native – all while taking advantage of the native platform’s visual fidelity, performance, and accessibility. \n\nWhether you have a React Native mobile app or are interested in building a Windows-first app, you can use React Native for Windows to bring your app to Windows with the same quality as built-in Windows components like the **Your Microsoft Account** page. \n\nIf you’re interested in getting started with React Native for Windows, check out our website at [aka.ms/reactnative](https://aka.ms/reactnative). \n\nYou can also follow us on Twitter [@ReactNativeMSFT](https://twitter.com/reactnativemsft) to keep up to date on news, feature roadmaps, and more."
    },
    {
      "id": "/2021/08/05/win32component",
      "metadata": {
        "permalink": "/react-native-windows/blog/2021/08/05/win32component",
        "source": "@site/blog/2021-08-05-win32component.md",
        "title": "Use Win32 features from a React Native for Windows application",
        "description": "How to use Win32 features from a React Native for Windows application",
        "date": "2021-08-05T00:00:00.000Z",
        "formattedDate": "August 5, 2021",
        "tags": [],
        "readingTime": 22.465,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Matteo Pagani",
            "url": "https://twitter.com/qmatteoq"
          }
        ],
        "frontMatter": {
          "title": "Use Win32 features from a React Native for Windows application",
          "author": "Matteo Pagani",
          "authorURL": "https://twitter.com/qmatteoq",
          "description": "How to use Win32 features from a React Native for Windows application",
          "is_blog": true,
          "published_date": "August 30, 2021"
        },
        "prevItem": {
          "title": "React Native for Windows is helping Settings improve more quickly",
          "permalink": "/react-native-windows/blog/2022/02/11/settings"
        },
        "nextItem": {
          "title": "Add Toast notifications to your React Native for Windows application",
          "permalink": "/react-native-windows/blog/2021/06/30/notifications"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/win32component/\" />\n</head>\n\nIf you have adopted React Native to build your Windows applications, you'll know that the final output is a [Universal Windows Platform application](https://docs.microsoft.com/windows/uwp/get-started/universal-application-platform-guide). This development platform gives you access to all the latest enhancements in the Windows ecosystem (modern UI platform, notifications, integration with features like inking and Windows Hello, etc.), plus greater security and reliability thanks to the sandbox the application runs in.\nHowever, there might be scenarios where UWP isn't enough and you need to perform one or more tasks which are supported only by the Win32 ecosystem: working with any file on the disk without user intervention, reading a key from the registry, integrating a SDK which doesn't support the Windows Runtime.\n\nIn this post we're going to explore a solution that will enable you to get the best of both worlds: a React Native for Windows application which integrates a classic Win32 process. We're going to build a sample React Native application which will be able to read a registry key and display it. The goal is to display to the user values stored in the `\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion` hive, which contains many information about the currently installed version of Windows.\n\n<!--truncate-->\n\nThe solution will use the following components.\n\n#### A classic Windows process\n\nWe're going to build a .NET 5.0 console application which, by targeting Windows 10 and using the [Windows Compatibility Pack](https://docs.microsoft.com/dotnet/core/porting/windows-compat-pack), will be able to interact with the system registry. The React Native application will send to this process the name of the key we want to retrieve; the process will read its value and send it back to the React Native application.\n\n#### A React Native for Windows application\n\nThis will be a traditional React Native for Windows application. However, as we're going to see later, we'll have to make a couple of changes to the host app generated by the template to handle the communication with the classic Windows process.\n\n#### App Services\n\n[App Services](https://docs.microsoft.com/windows/uwp/launch-resume/app-services) is a UWP feature that enables a Windows application to host one or more background tasks that can be consumed by other applications. You can think of this feature like REST services, but exposed locally. Once a UWP application which exposes an App Service is deployed on a machine, other applications can connect to it using its name and the Package Family Name of the hosting application. Once the communication channel is established, the calling application can send data to the App Service, which will process it and send back the results.\n\nIn our context, App Service will enable us to create a communication channel between the React Native application and the classic Win32 process. The main difference compared to the traditional usage is that the App Service will be hosted and consumed by the same package, since the two processes (UWP and classic Win32) will be packaged together.\n\nApp Services support two approaches: [in-proc](https://docs.microsoft.com/windows/uwp/launch-resume/convert-app-service-in-process) (when the implementation of the service is defined in the main application itself) and [out-of-proc](https://docs.microsoft.com/windows/uwp/launch-resume/how-to-create-and-consume-an-app-service) (when the implementation of the service is defined in an external Windows Runtime Component, which gets executed in a different process). For our scenario, we must use the in-proc approach, since we need to hold a direct connection with the main application.\n\n#### A native module\n\n[A native module](https://microsoft.github.io/react-native-windows/docs/native-modules) is the way to expose native features to the JavaScript layer of React Native application. In the Windows context, a native module is a Windows Runtime Component that, through attributes which decorates your code, can expose methods, properties and events to JavaScript.\nThe native module is needed as a glue between the React Native world and the UWP world. All the APIs to interact with an App Service are exposed by the Windows Runtime and, as such, we need a middle man that can make them accessible to JavaScript.\n\n#### Windows Application Packaging Project\n\nA [Windows Application Packaging Project](https://docs.microsoft.com//windows/msix/desktop/desktop-to-uwp-packaging-dot-net) (WAP project, from now on) is a template available in Visual Studio, which is typically used to package as MSIX classic Windows application. In our context, we're going to use it to bundle together the classic Win32 process and the React Native for Windows application in the same MSIX package.\n\nThe diagram below shows how all these components are tight together:\n\n![The architecture of the solution we're going to build in the article](assets/2021-05-08-win32component/architecture.png)\n\n1. The user launches the React Native application which, at the same time, starts also the classic Win32 process.\n2. The Win32 process, at startup, establishes a communication with the React Native application using an App Service and it stores a reference to the channel.\n3. The user presses a button in the React Native application.\n4. The button will invoke a method method exposed by the native module. The method will push a message to the communication channel, so that it can be received by the classic Win32 process. The message will contain the information about the key that the Windows process must retrieve from the registry.\n5. The classic Win32 process retrieves the desired key from the registry, it stores it inside another message and it sends it back to the communication channel.\n6. The native module, which is using the App Service to keep the communication channel open, receives the message with the retrieved key and it sends it back to the JavaScript layer.\n7. The React Native application can now show to the user the value of the registry key.\n\nLet's start building all the components!\n\n> All the samples you'll find below (including the native module and the React Native host app) will be based on C#, since it's the language I'm most familiar with. However, the same goal can be achieved also using the C++ templates.\n\n### The classic Win32 process\n\nFor the purpose of this sample, we're going to use a .NET 5.0 console application. Open with Visual Studio the solution included in the `windows` folder of your React Native application, right click on it and choose **Add -> New project**. Choose **Console application** as template.\n\nBefore starting to write some code, we need to make a few changes:\n\n1. Double click on the project and change the `TargetFramework` from `net5.0` to `net5.0-windows10.0.19041.0`. The new target will enable you to leverage Windows 10 APIs from your .NET application. It's required in our scenario since we need to use the App Service APIs.\n2. Right click on the project, choose **Manage NuGet Packages** and install the [Microsoft.Windows.Compatibility](https://www.nuget.org/packages/Microsoft.Windows.Compatibility) package. It will give us access to the APIs to interact with the Windows registry.\n3. Right click on the project, choose **Properties** and change the **Output type** from **Console Application** to **Windows Application**. Thanks to this change, our application will run headless, without any visible UI. This helps to achieve a good user experience, since our classic Win32 process will run only in background. All the UI and interaction will be handled by the React Naive application.\n\nThe application will run continuously in background, until the main React Native application will be closed. To achieve this goal, we start the main process in a separate thread, which gets terminated when the connection with the App Service is closed (which means that the application is closed). This approach ensures that the classic Win32 application doesn't become a \"zombie\" process, which stays alive even if the main app has been shut down.\n\n```csharp\nstatic AutoResetEvent appServiceExit;\nstatic AppServiceConnection connection = null;\n\nstatic void Main(string[] args)\n{\n    appServiceExit = new AutoResetEvent(false);\n    Thread appServiceThread = new Thread(new ThreadStart(ThreadProc));\n    appServiceThread.Start();\n    appServiceExit.WaitOne();\n}\n```\n\nThe code above starts the execution of a method (called `ThreadProc`) in a separate thread. We use an `AutoResetEvent` to block the execution of the `Main()` method. This way, we make sure that the process will keep running until the communication channel created with the App Service is alive.\n\nThe `ThreadProc` method is the real \"core\" of the process, which takes care of initializing the connection with the App Service:\n\n```csharp\nstatic async void ThreadProc()\n{\n    connection = new AppServiceConnection();\n    connection.AppServiceName = \"RegistryService\";\n    connection.PackageFamilyName = Windows.ApplicationModel.Package.Current.Id.FamilyName;\n    connection.RequestReceived += Connection_RequestReceived;\n    connection.ServiceClosed += Connection_ServiceClosed;\n\n    //we open the connection\n    AppServiceConnectionStatus status = await connection.OpenAsync();\n\n    if (status != AppServiceConnectionStatus.Success)\n    {\n        //if the connection fails, we terminate the Win32 process\n        appServiceExit.Set();\n    }\n}\n```\n\nWe create a new `AppServiceConnection` and we configure it in the following way:\n\n- We specify the name of the App Service we want to connect to, using the `AppServiceName` property. This name must match the one we're going to include inside the manifest of the Windows Application Packaging Project in a later stage.\n- We specify the Package Family Name of the application which hosts the App Service. In our scenario, since the React Native application and the classic Win32 process are hosted in the same package, we can retrieve it using the `Windows.ApplicationModel.Package` APIs.\n- We subscribe to two events: `RequestReceived`, which is triggered when the React Native application sends a message; `ServiceClosed`, which is triggered when the App Service channel is shut down.\n\nThen we use the `OpenAsync()` method to open the connection. If it isn't successful, there's no need for this process to stay alive, so we call `Set()` on the `AutoResetEvent` object, so that the `Main()` method can terminate.\n\nLet's see now the implementation of the two event handlers. The first one, `ServiceClosed`, is the easiest one:\n\n```csharp\nprivate static void Connection_ServiceClosed(AppServiceConnection sender, AppServiceClosedEventArgs args)\n{\n    //when the connection with the App Service is closed, we terminate the Win32 process\n    appServiceExit.Set();\n}\n```\n\nIf the communication with the App Service drops, we simply call `Set()` on the `AutoResetEvent` object so that the process can terminate.\n\nThe second one, `RequestReceived`, instead, is the one where the communication with the React Native application happens:\n\n```csharp\nprivate static async void Connection_RequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n{\n    string key = args.Request.Message[\"RegistryKeyName\"].ToString();\n\n    var hive = Registry.LocalMachine.OpenSubKey(@\"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\", false);\n    string value = hive.GetValue(key).ToString();\n\n    ValueSet valueSet = new ValueSet\n    {\n        { \"RegistryKeyValue\", value }\n    };\n\n    await args.Request.SendResponseAsync(valueSet);\n}\n```\n\nFrom the `Request.Message` dictionary of the event arguments, we can retrieve any information passed by the main React Native application. In our scenario, the name of the requested registry key will be stored in an item with `RegistryKeyName` as key.\nWe use this information to connect to the registry (using the `Registry` APIs) and to retrieve this key from `SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion`, which is the hive that contains all the information about the currently installed version of Windows.\n\nOnce we have retrieved the key, we stored it a new message (the `ValueSet` object) with key `RegistryKeyValue`. In the end, we send it back using the `SendResponseAsync()` method, so that the caller (in our case, the native module) can use it.\n\n### The React Native for Windows application\n\nWhen the classic Windows application invokes the `OpenAsync()` method to connect to the App Service, the host UWP app will wake up to respond (remember that we're using an in-proc App Service). This scenario is handled by a special event called `OnBackgroundActivated`, which you can subscribe in the `App` class of the host app. This is the implementation:\n\n```csharp\nprotected override void OnBackgroundActivated(BackgroundActivatedEventArgs args)\n{\n    base.OnBackgroundActivated(args);\n\n    if (args.TaskInstance.TriggerDetails is AppServiceTriggerDetails details)\n    {\n        appServiceDeferral = args.TaskInstance.GetDeferral();\n\n        var ns = ReactPropertyBagHelper.GetNamespace(\"RegistryChannel\");\n        var name = ReactPropertyBagHelper.GetName(ns, \"AppServiceConnection\");\n\n        InstanceSettings.Properties.Set(name, details.AppServiceConnection);\n    }\n}\n```\n\nFirst, we check if the type of activation is `AppServiceTriggerDetails`, since the application might have other background activation entry points. If that's the case we retrieve a deferral and we store it as a class variable:\n\n```csharp\nsealed partial class App : ReactApplication\n{\n    private BackgroundTaskDeferral appServiceDeferral;\n\n    public App() \n    {\n        // ...\n    }\n    \n    // ...\n}\n```\n\nThe deferral is [a concept used by the Universal Windows Platform](https://blogs.windows.com/windowsdeveloper/2016/04/28/the-lifecycle-of-a-uwp-app/) to properly handle asynchronous methods in background tasks. Since, when an asynchronous method is started, its execution is delegated to another thread, the background task might think that the operation is completed so Windows will terminate it. To avoid this scenario, we use a deferral to manually tell to the background task when the operation is really completed, by calling the `Complete()` method at the end. However, in our scenario, we just need to call `GetDeferral()` to get one, but we don't actually need to complete it, since we want our channel to stay alive until the application is running. If we don't do this, the channel would open, but it would be closed after a few seconds.\n\nThe last past of the code introduces a new concept, which are **React Property Bags**. This is a feature included in React Native which enables to share key / value pairs across an entire React Native application, including its modules. Why do we need it? Since we're building a React Native app, the UWP application won't contain the actual code which interacts with the App Service, but it will just host the JavaScript layer. As such, the communication will be handled by the native module. Thanks to React Property Bags, we can store a reference to the App Service in the host but let the native module use it.\n\nThe code creates a new property bag, which is composed by a namespace (`RegistryChannel`) and a name (`AppServiceConnection`). Then, using the `InstanceSettings` static class, we create the property bag in the current instance, by calling the `Set()` method and passing, as object to store, the App Service channel we have just created.\n\n### The native module\n\nNow we are ready to interact with the classic Win32 process we have previously built. In a regular UWP scenario, we would have interacted with the App Service directly in the main application. However, in React Native for Windows, the UWP app is just a host for the JavaScript layer, so we need to build a native module to expose the APIs we need to JavaScript.\n\nThe next step is to add a native module to your solution. This is well documented in the [official documentation](https://microsoft.github.io/react-native-windows/docs/native-modules-setup). The module I'm going to build is a C# Windows Runtime Component, but of course you can do the same in C++.\n\nBy default, the module will contain two classes: one called `ReactPackageProvider`, which handles the registration in the main app, and one called `ReactNativeModule`, which contains the module definition. The default implementation of the class provided by the template will look like this:\n\n```csharp\nnamespace ReactNativeAppServiceModule\n{\n[ReactModule(\"ReactNativeAppServiceModule\")]\ninternal sealed class ReactNativeModule\n{\n\n    private ReactContext _reactContext;\n\n    [ReactInitializer]\n    public void Initialize(ReactContext reactContext)\n    {\n        _reactContext = reactContext;\n    }\n\n    [ReactMethod]\n    public void sampleMethod(string stringArgument, int numberArgument, Action<string> callback)\n    {\n        // TODO: Implement some actually useful functionality\n        callback(\"Received numberArgument: \" + numberArgument + \" stringArgument: \" + stringArgument);\n    }\n}\n}\n```\n\nThe class already includes many elements we're going to need, like the `[ReactModule]` attribute to expose the module to JavaScript; the `[ReactMethod]` attribute to expose a method to JavaScript; the `[ReactInitializer]` attribute, which decorates the method that give us access to the `ReactContext` property. This is the object that will contain the property bag we have set in the main application.\n\nKeep everything as it is, but delete the `sampleMethod()` function. We're going to replace it with the real methods that we need to expose to JavaScript.\n\nLet's start with the first one:\n\n```csharp\n[ReactMethod(\"launchFullTrustProcess\")]\npublic async Task LaunchFullTrustProcessAsync()\n{\n    await FullTrustProcessLauncher.LaunchFullTrustProcessForCurrentAppAsync();\n}\n```\n\nThis method uses the `FullTrustProcessLauncher` API to launch a classic Win32 process from a UWP application. We just need to call it as it is. We're going to specify the information about the process to launch later in the manifest. Later, we're going to call this method from the JavaScript layer when the application starts.\nBy default, the `FullTrustProcessLauncher` class won't be found. The reason is that this API isn't included in UWP by default, but it's part of the specific extensions for desktop. As such, you have to right click on the native module's project, choose **Add reference** and, in the **Universal Windows -> Extensions** section, click on the latest version of the `Windows Desktop Extension for UWP`.\n\n![How to enable the Windows Desktop Extensions for UWP](assets/2021-05-08-win32component/desktop-extensions.png)\n\nLet's see now the second method:\n\n```csharp\n[ReactMethod(\"getRegistryKey\")]\npublic async Task<string> GetRegistryKey(string key)\n{\n    var ns = ReactPropertyBagHelper.GetNamespace(\"RegistryChannel\");\n    var name = ReactPropertyBagHelper.GetName(ns, \"AppServiceConnection\");\n\n    var content = _reactContext.Handle.Properties.Get(name);\n\n    var _connection = content as AppServiceConnection;\n\n    ValueSet valueSet = new ValueSet\n    {\n        { \"RegistryKeyName\", key }\n    };\n\n    var result = await _connection.SendMessageAsync(valueSet);\n\n    string message = result.Message[\"RegistryKeyValue\"].ToString();\n    return message;\n}\n```\n\nThis is the method that we'll invoke from the React Native application when we want to retrieve the value of a registry key. Through the `ReactContext` object we have retrieved in the initialization of the module, we can use the `Properties` collection to access to the property bags. We look for one called `AppServiceConnection` in the `RegistryChannel` namespace, which contains the reference to our App Service channel.\nOnce we have the channel, we can use it to send a message with the name of the key we want to retrieve (encapsulated in a `ValueSet` object) to the classic Win32 process using the `SendMessageAsync()` method. The message will be received by the Win32 process, which will retrieve the value of the requested key from the registry, and then it will send it back to our native module, as result of the `SendMessageAsync()` method. The response will be included in the `Message` collection with key `RegistryKeyValue`: we simply return this value to the JavaScript layer, so that the React Native app can display it.\n\nThere's one last step to do. Since we have manually created this module, we have also to manually register it in the main host application. As first step, right click on the host app, choose **Add reference** and select the native module. Then move to the `App` class and, in the constructor, add the following line before the `InitializeComponent()` method is invoked:\n\n```csharp\nPackageProviders.Add(new ReactNativeAppServiceModule.ReactPackageProvider());\n```\n\nIn case you have created the native module with a different name, make sure to replace `ReactNativeAppServiceModule` with the correct namespace.\n\n### The Windows Application Packaging Project\n\nThe last step before we can try our solution is to add a Windows Application Packaging Project, which will help us to put together inside the same package the host UWP app and the classic Win32 process. Right click on the solution, choose **Add -> New project** and look for the template called **Windows Application Packaging Project**. Once you have added it, right click on it and choose **Add reference**. Now you have to select two projects from your solution: the React Native host UWP app and the classic Win32 process. Once it's done, expand the **Applications** node, right click on the name of the host UWP app and choose **Set as entry point**. This will ensure that, when you click on the app icon in the Start menu, the main React Native app will be the one being launched.\n\nNow we have to make a few changes to the manifest. One of the important differences you have to be aware when you introduce the Windows Application Packaging Project in a scenario like ours is that its manifest becomes the main one. As such, if you have previously customized the manifest of your host UWP app (for example, by adding assets for the icons, changing the identity or adding a few capabilities), you will have to port them in the manifest of the WAP project.\nFor this exact reason, make sure to make the following changes in the `Package.appxmanifest` file of the WAP project and not in the one of the host UWP app.\n\nThe first change is declaring the App Service. If you remember, previously in code we had to specify two information to connect to the App Service from the Win32 classic process: the name and the Package Family Name. The name is defined exactly in the manifest. Double click on the **Package.appxmanifest** file, move to the **Declarations** tab and, from the dropdown, choose **App Service** and click **Add**. The only required field is **Name**, which we have to fill with the same name that we have previously specified in code, which is `RegistryService`. Since it's an in-proc App Service, we don't have to specify any other information.\n\n![How to declare an App Service in the manifest](assets/2021-05-08-win32component/appservice-manifest.png)\n\nThe second change is declaring which is the classic Win32 process that we want to launch when we use the `FullTrustLauncher` API. This feature isn't supported by the Visual Studio UI, so you'll have to right click on the `Package.appxmanifest` file and choose **View code**. You will find a section called `Extensions`, where the App Service has been declared. Exactly below, add the following entry:\n\n```xml\n<Extensions>\n  <uap:Extension Category=\"windows.appService\">\n    <uap:AppService Name=\"RegistryService\"/>\n  </uap:Extension>\n  <desktop:Extension Category=\"windows.fullTrustProcess\" Executable=\"RegistryApp\\RegistryApp.exe\" />\n</Extensions>\n```\n\nThe `Executable` attribute specifies the path of the classic Win32 process inside the package. By default, the WAP project puts all the build outputs inside a folder with the same name of the project. As such, our classic Win32 app will be available at the path `RegistryApp\\RegistryApp.exe`. \nTo make this extension working, you will have also to declare the `desktop` namespace at the top, since it isn't included by default:\n\n```xml\n<Package\n  xmlns=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\"\n  xmlns:uap=\"http://schemas.microsoft.com/appx/manifest/uap/windows10\"\n  xmlns:desktop=\"http://schemas.microsoft.com/appx/manifest/desktop/windows10\"\n  IgnorableNamespaces=\"uap desktop\">\n```\n\nThe final change we would need to make is to add a capability called **runFullTrust**, which enables our package to include a classic Win32 component and not just a UWP application. However, the default manifest included in the WAP project already defines that. You can see it in the `Capabilities` section of the manifest:\n\n```xml\n<Capabilities>\n  <Capability Name=\"internetClient\" />\n  <rescap:Capability Name=\"runFullTrust\" />\n</Capabilities>\n```\n\n### The React Native application\n\nFinally, we now have all the pieces of the puzzle and we can start working on the JavaScript layer. As first step, we need to launch the classic Win32 process when the React Native application starts. If you're using a functional component, you can use the `useEffect` hook; if you're using a class component, you can use the `componentDidMount` event. In my case, I'm going for the first option, so I added in my application the following function:\n\n```javascript\nuseEffect(() => {\n  async function launchProcess() {\n    await NativeModules.ReactNativeAppServiceModule.launchFullTrustProcess();\n  }\n  launchProcess();\n}, []);\n```\n\nIf you have used native modules before, the code should be easy to understand. We use the `NativeModules` API in React to access to our native module, by specifying its name (`ReactNativeAppServiceModule`, which we have set using the `[ReactModule]` attribute) and the method (`launchFullTrustProcess()`, which we have set using the `[ReactMethod]` attribute).\n\nThe outcome is that, when you launch the main app from the Start menu, also the classic Win32 process will be launched. However, since it doesn't have any UI, it will run in background. You'll be able to see it using Task Manager:\n\n![The Win32 classic process running in background in Task Manager](assets/2021-05-08-win32component/registryapp.png)\n\nNow we need to store two information in the component's state: the name of the registry key we want to get (which will be filled by the user using a `TextInput` control) and its value, which will be returned by our native module. Since I'm using a functional component, I'm going to use the `useState` hook:\n\n```javascript\nconst[registryKeyName, setRegistryKeyName] = useState('');\nconst[registryKeyValue, setRegistryKeyValue] = useState('');\n```\n\nNow let's define the function that will invoke the native module to get the registry key and will store the result in the state:\n\n```javascript\nconst getRegistryKey = async() => {\n  var result = await NativeModules.ReactNativeAppServiceModule.getRegistryKey(registryKeyName);\n  setRegistryKeyValue(result);\n}\n```\n\nThe approach is the same as the previous one: the only difference is that, this time, we're invoking the `getRegistryKey()` function, which requires as parameter the name of the key we want to retrieve from the `HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion` hive.\n\nNow let's build a minimal UI: a `TextInput` control, which will read the name of the registry key and store it in the state; a `Button`, which will invoke the `getRegistryKey()` function; a `Text`, which will display the value returned by the function.\n\n```jsx\n<View>\n  <TextInput onChangeText={text => setRegistryKeyName(text)} />\n  <Button title=\"Get registry key\" onPress={getRegistryKey} />\n  <Text>{registryKeyValue}</Text>\n</View>\n```\n\n### Running the app\n\nWe're ready to test our work! First, go to Visual Studio, right click on the Windows Application Packaging Project and choose Deploy. You might get the following error:\n\n```plaintext\nError Task 'AddProjectMetadata' failed. The expression \"[MSBuild]::MakeRelative(C:\\ReactCSharp, *Undefined*)\" cannot be evaluated. Illegal characters in path. C:\\ReactCSharp\\node_modules\\react-native-windows\\PropertySheets\\Autolink.props\nReactCSharp.Package C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Enterprise\\MSBuild\\Microsoft\\DesktopBridge\\Microsoft.DesktopBridge.targets 408 \nError MSB4184 The expression \"[MSBuild]::MakeRelative(C:\\ReactCSharp, *Undefined*)\" cannot be evaluated. Illegal characters in path. C:\\ReactCSharp\\node_modules\\react-native-windows\\PropertySheets\\Autolink.props ReactCSharp.Package C:\\ReactCSharp\\node_modules\\react-native-windows\\PropertySheets\\Autolink.props 12\n```\n\nIf that's a case, this is a known issue that has already been addressed, but the fix isn't available yet in the latest stable React Native for Windows version. However, the workaround is easy. Open the file in the path `node_modules\\react-native-windows\\PropertySheets\\Autolink.props` and replace the following line:\n\n```xml\n<AutolinkCommandArgs Condition=\"'$(AutolinkCommandArgs)' == '' And '$(SolutionPath)' != '' And '$(ProjectPath)' != ''\">--check --sln $([MSBuild]::MakeRelative($(AutolinkCommandWorkingDir), $(SolutionPath))) --proj $([MSBuild]::MakeRelative($(AutolinkCommandWorkingDir), $(ProjectPath)))</AutolinkCommandArgs>\n```\n\nwith\n\n```xml\n<AutolinkCommandArgs Condition=\"'$(AutolinkCommandArgs)' == '' And '$(SolutionPath)' != '' And '$(SolutionPath)' != '*Undefined*' And '$(ProjectPath)' != ''\">--check --sln $([MSBuild]::MakeRelative($(AutolinkCommandWorkingDir), $(SolutionPath))) --proj $([MSBuild]::MakeRelative($(AutolinkCommandWorkingDir), $(ProjectPath)))</AutolinkCommandArgs>\n```\n\nIf you're building the project for the first time, it will take a while. Once it's deployed, you will find two entries in the Start menu: one for the base host app (for example, `appservicedemo`) and one for the WAP project (for example, `appservicedemo.Package`). Don't worry, when you will generate a MSIX package for release this won't happen anymore. However, if you want to remove this confusion also while you're debugging, just go back to Visual Studio, choose **Build -> Configuration Manager** and make sure that the **Deploy** flag is turned on only for the WAP project.\n\n![The Visual Studio configuration to deploy only the WAP project](assets/2021-05-08-win32component/defaultproject.png)\n\nBefore clicking on the Start menu entry for the WAP project, make sure to open a terminal on the folder which contains your project and run `yarn start` to launch the Metro packager.\nIf everything went well, the UI of the app should show up. Specify in the text box the name of one of the keys in the `HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion` registry hive (for example, `BuildLab`) and press the button. If you did everything correctly, the value of the key will be displayed:\n\n![The final application running](assets/2021-05-08-win32component/final-app.png)\n\nIf you want to create a package for release (to publish on the Microsoft Store or sideload on another machines), make sure to start the wizard (**Publish --> Create App Packages**) from the WAP project and not from the host app, otherwise the classic Win32 process won't be included.\n\n### Conclusion\n\nIt was a long journey, but now we have a React Native for Windows application which can interact with the Win32 ecosystem. In this article we built a sample scenario based on registry access, but the opportunities are unlimited! You can integrate SDKs which aren't supported by the Universal Windows Platform; or enhance your React Native application with features that otherwise won't be supported. You can find the sample project built for this article [on GitHub](../../samples/AppServiceDemo).\n\n### Credits\n\nIcons used in the architecture:\n\n- [React Flat Icon](https://iconscout.com/icons/react) by [Icon Mafia](https://iconscout.com/contributors/icon-mafia)\n- [Windows Flat Logo Icon](https://iconscout.com/icons/windows) [Icon Mafia](https://iconscout.com/contributors/icon-mafia)\n- [Package Colored Outline Icon](https://iconscout.com/icons/package) by [Vichanon Chaimsuk](https://iconscout.com/contributors/ferdizzimo)"
    },
    {
      "id": "/2021/06/30/notifications",
      "metadata": {
        "permalink": "/react-native-windows/blog/2021/06/30/notifications",
        "source": "@site/blog/2021-06-30-notifications.md",
        "title": "Add Toast notifications to your React Native for Windows application",
        "description": "Add Windows toast notifications to a React Native for Windows application",
        "date": "2021-06-30T00:00:00.000Z",
        "formattedDate": "June 30, 2021",
        "tags": [],
        "readingTime": 5.55,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Alexander Sklar",
            "url": "https://twitter.com/alexsklar"
          }
        ],
        "frontMatter": {
          "title": "Add Toast notifications to your React Native for Windows application",
          "author": "Alexander Sklar",
          "authorURL": "https://twitter.com/alexsklar",
          "description": "Add Windows toast notifications to a React Native for Windows application",
          "is_blog": true,
          "published_date": "June 30, 2021"
        },
        "prevItem": {
          "title": "Use Win32 features from a React Native for Windows application",
          "permalink": "/react-native-windows/blog/2021/08/05/win32component"
        },
        "nextItem": {
          "title": "Add inking to your React Native for Windows application",
          "permalink": "/react-native-windows/blog/2021/05/25/inking"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/react-native-windows-notifications/\" />\n</head>\n\nIn this article, we will discuss how to enable your app to show toast notifications, which you can use to notify the user that something needs their attention, or to notify them that a long running operation has completed.\n\n<!--truncate-->\n\n### Create a native module\n\nThis article assumes you have some familiarity with React Native for Windows native modules. If you need a refresher, check out [the native modules documentation](https://microsoft.github.io/react-native-windows/docs/next/native-modules).\n\nThe Windows toast notification API is fairly rich: it includes a number of UI _templates_ that an app can use to customize how it wants the notification to look. \nSome templates include text only, while others include text and images. Every template has some combination of these. You can see a list of the available templates [here](https://docs.microsoft.com/en-us/previous-versions/windows/apps/hh761494(v=win.10)).\n\nWe will create a native module which will have a single method, `raise`. The Windows toast notification API takes an XML document as input, which will specify the text and image sources that we want to show. However, it would be much more natural for us to work with JavaScript objects and JSON instead of XML markup.\nSo our `raise` method will take a JS object, which will include what template the app wants to use, as well as arrays of text and images that apply to the template. We will take the information in this JS object, and use it to construct the XML that we need to pass to the platform API.\n\n### Create a module \n\nFor the purpose of our demo, we will add a native module directly to a C++/WinRT example app. If you prefer, you can follow the steps below and apply them to a separate native module project. Note that you can also use C# to write native modules in a similar manner.  For more information about choosing between C++/WinRT and C#, see [Native code language choice](https://microsoft.github.io/react-native-windows/docs/native-code-language-choice).\nWe will start with our standard native module setup, by adding a `Notifications.h` file to our example app project. In this initial version, we'll use the simplest static Toast template (one string of text), so we'll have our `raise` method take a string:\n\n```cpp\n#pragma once\n#include <NativeModules.h>\n#include <winrt/Windows.UI.Notifications.h>\n#include <winrt/Windows.Data.Xml.Dom.h>\n\nusing namespace winrt::Windows::UI::Notifications;\nusing namespace winrt::Windows::Data::Xml::Dom;\n\n\nREACT_MODULE(Notifications)\nstruct Notifications {\n\n  REACT_INIT(Initialize);\n  void Initialize(React::ReactContext const& context) noexcept {\n    m_context = context;\n  }\n\n  REACT_METHOD(Raise, L\"raise\");\n  void Raise(const std::string& text) noexcept\n  {\n  }\n\nprivate:\n  React::ReactContext m_context;\n};\n```\n\nThen in our app's `ReactPackageProvider.cpp`, we just include our new header:\n```diff\n#include \"pch.h\"\n#include \"ReactPackageProvider.h\"\n#include \"NativeModules.h\"\n+#include \"Notifications.h\"\nusing namespace winrt::Microsoft::ReactNative;\n\nnamespace winrt::example::implementation\n{\n\nvoid ReactPackageProvider::CreatePackage(IReactPackageBuilder const &packageBuilder) noexcept\n{\n    AddAttributedModules(packageBuilder);\n}\n\n} // namespace winrt::example::implementation\n```\n\n### Starting simple\n\nIn our JavaScript (`App.tsx` or `App.js`), we will import NativeModules and add a button that calls into our `raise` API when clicked. Here we are using a [react-native-xaml](https://github.com/asklar/react-native-xaml) Button component, but you can use any UI component and toolkit you'd like. \nNormally, you would call the `raise` API in response to some other event, like an upload/download operation completing.\n\n```jsx\nimport {\n  // ...\n  NativeModules\n} from 'react-native';\nimport {Button} from 'react-native-xaml';\n\n// ...\n  <Button onClick={() => {\n      NativeModules.Notifications.raise(\"hello\");\n  }} content=\"click me to send a toast\" />\n```\n\nSo now we have the basic setup, and you can set a breakpoint in the C++ code and validate that clicking on the button breaks into the C++ `Raise` method.\nNow we get to have fun. First let's try the simplest static Toast template, `ToastText01`. This template just has one value for us to fill out, the text we want to show.\nHere's the logic to send a toast using this template, in C++:\n```cpp\n  REACT_METHOD(Raise, L\"raise\");\n  void Raise(const std::string& textToShow) noexcept\n  {\n    auto xml = ToastNotificationManager::GetTemplateContent(ToastTemplateType::ToastText01);\n    for (auto& element : xml.GetElementsByTagName(L\"text\")) {\n      element.AppendChild(xml.CreateTextNode(winrt::to_hstring(textToShow)));\n    }\n\n    auto toast = ToastNotification(xml);\n    ToastNotificationManager::CreateToastNotifier().Show(toast);\n  }\n```\n\n### Complete solution\n\nNote that it is necessary to convert the string values we get from JavaScript (as `std::string` values which are UTF-8) onto platform strings (`winrt::hstring`), which are UTF-16, so we use the `winrt::to_hstring` helper for that.\nNow that we have the simple case, it's time to crank it up a notch: we want to be able to use any of the available toast templates, which can have a number of text strings and images. The image elements have a `src` attribute as well as an `alt` attribute for accessibility.\n\n```cpp\n  REACT_METHOD(Raise, L\"raise\");\n  void Raise(const React::JSValue& notification) noexcept\n  {\n\n    ToastTemplateType type = ToastTemplateType::ToastText01;\n\n    React::JSValueObject obj;\n    if (notification.Type() == React::JSValueType::String)\n    {\n      obj[\"text\"] = notification.AsString();\n    }\n    else {\n      obj = notification.AsObject().Copy();\n    }\n\n    auto typeEntry = obj.find(\"template\");\n    if (typeEntry != obj.end() && typeEntry->second.Type() == React::JSValueType::Int64) {\n      type = static_cast<ToastTemplateType>(typeEntry->second.AsInt32());\n    }\n\n    auto xml = ToastNotificationManager::GetTemplateContent(type);\n\n    for (const auto& entry : obj)\n    {\n      const auto tagName = winrt::to_hstring(entry.first);\n      auto xmlElements = xml.GetElementsByTagName(tagName);\n      \n      if (entry.second.Type() == React::JSValueType::String) {\n        React::JSValueArray strToArray;\n        strToArray.push_back(entry.second.AsString());\n        FillXmlElements(xml, xmlElements, strToArray);\n      }\n      else if (entry.second.Type() == React::JSValueType::Object) {\n        React::JSValueArray objToArray;\n        objToArray.push_back(entry.second.AsObject().Copy());\n        FillXmlElements(xml, xmlElements, objToArray);\n      } else {\n        FillXmlElements(xml, xmlElements, entry.second.AsArray());\n      }\n    }\n\n\n    auto toast = winrt::Windows::UI::Notifications::ToastNotification(xml);\n    ToastNotificationManager::CreateToastNotifier().Show(toast);\n  }\n\n\nprivate:\n  React::ReactContext m_context;\n\n  void FillXmlElements(const XmlDocument& xml, const XmlNodeList& xmlElements, const React::JSValueArray& arr) {\n    int i = 0;\n    for (const auto& arrValue : arr) {\n      auto node = xmlElements.GetAt(i++);\n      if (arrValue.Type() == React::JSValueType::String) {\n        const auto value = winrt::to_hstring(arrValue.AsString());\n        node.AppendChild(xml.CreateTextNode(value));\n      }\n      else if (arrValue.Type() == React::JSValueType::Object) {\n        const auto& arrValueObj = arrValue.AsObject();\n        for (const auto& entry : arrValueObj) {\n          auto attrName = winrt::to_hstring(entry.first);\n          auto attr = node.Attributes().GetNamedItem(attrName);\n          if (!attr) {\n            attr = xml.CreateAttribute(attrName);\n            node.Attributes().SetNamedItem(attr);\n          }\n\n          attr.NodeValue(winrt::box_value(winrt::to_hstring(entry.second.AsString())));\n        }\n      }\n    }\n  }\n```\n\nThe code above will enable us to specify a `template` attribute, that we will set to be the numeric value of the template we want to use. You can find a table of such values in the [ToastTemplateType docs](https://docs.microsoft.com/uwp/api/Windows.UI.Notifications.ToastTemplateType). For example, `ToastText01` has a value of 4, so we'd specify `template: 4`.\nIt will also iterate through the rest of our JavaScript object parameter to discover the key/value pairs we want to set and apply them to the underlying XML that we will later pass to the platform.\nHere is how you'd use this complete version from JavaScript:\n\n```jsx\n  <Button onClick={() => {\n      NativeModules.Notifications.raise({\n          template: 0, // ToastImageAndText01 - see https://docs.microsoft.com/uwp/api/Windows.UI.Notifications.ToastTemplateType\n          // The template schema can be found at https://docs.microsoft.com/previous-versions/windows/apps/hh761494(v=win.10)\n          text: \"hello world\",\n          image: {\n              src: \"https://microsoft.github.io/react-native-windows/img/header_logo.svg\",\n              alt: \"React logo\",\n          }\n      });\n  }} content=\"click me to send a toast\" />\n\n```\n\n### Wrapping up\n\nIn this article we have learned how to write a native module to call into the native Toast Notification APIs, and how to use the JSValue APIs to inspect values sent from the JavaScript side to the native module\n\nYou can find the `Notifications.h` header used in this article as a [GitHub Gist](https://gist.github.com/asklar/12273ce7991c084d7d5c357206174b2d)."
    },
    {
      "id": "/2021/05/25/inking",
      "metadata": {
        "permalink": "/react-native-windows/blog/2021/05/25/inking",
        "source": "@site/blog/2021-05-25-inking.md",
        "title": "Add inking to your React Native for Windows application",
        "description": "How to use add inking to a React Native for Windows application",
        "date": "2021-05-25T00:00:00.000Z",
        "formattedDate": "May 25, 2021",
        "tags": [],
        "readingTime": 15.99,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Matteo Pagani",
            "url": "https://twitter.com/qmatteoq"
          }
        ],
        "frontMatter": {
          "title": "Add inking to your React Native for Windows application",
          "author": "Matteo Pagani",
          "authorURL": "https://twitter.com/qmatteoq",
          "description": "How to use add inking to a React Native for Windows application",
          "is_blog": true,
          "published_date": "May 25, 2021"
        },
        "prevItem": {
          "title": "Add Toast notifications to your React Native for Windows application",
          "permalink": "/react-native-windows/blog/2021/06/30/notifications"
        },
        "nextItem": {
          "title": "Using CodePush in a React Native for Windows application",
          "permalink": "/react-native-windows/blog/2021/05/17/codepush"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/rnw-inking/\" />\n</head>\n\nWindows 10 is one of the most powerful platforms on the market when it comes to supporting digital inking experiences. As such, the Universal Windows Platform comes with a dedicated series of controls that you can add to your application to enable inking experiences. Thanks to these controls, you can easily implements features like capturing signatures, text and shape recognition, etc.\n\nIf you're building a Windows application with React Native, there are a few options you can explore to add such a feature. One of them is using a community module called [react-native-sketch-canvas](https://github.com/creambyemute/react-native-sketch-canvas), which provides a Windows implementation as well. This module is based on Win2D and it enables the recording and playback of ink strokes. While this solution can be a great fit for many applications, there are scenarios in which you need more precision and better integration with the Windows ecosystem, like when you need to capture a signature. For these purposes, Windows 10 offers a native control called [`InkCanvas`](https://docs.microsoft.com/uwp/api/Windows.UI.Xaml.Controls.InkCanvas), which enables powerful inking experiences. `InkCanvas` is specifically a Windows control and isn't exposed automatically by React Native. As such, we'll have to wrap it with a [native UI component](https://microsoft.github.io/react-native-windows/docs/view-managers), which is a feature provided by React Native which exposes native UI controls for Windows, Android or iOS to the JavaScript layer using JSX.\n\nIn this article we'll walk through the process of wrapping the `InkCanvas` control, with the dual goals of enabling your apps to support inking and walking you through the process of creating a native UI component, which can be useful for exposing other native controls.\n\n<!--truncate-->\n\n### Create a native module\n\nFrom a development perspective, there are no differences between [a native module](https://microsoft.github.io/react-native-windows/docs/native-modules) and a native UI component. They are both defined inside a Windows Runtime Component, which exposes a `ReactPackageProvider` class that gets registered by the main application via autolinking.\nYou can either choose to build [a dedicated native module library](https://microsoft.github.io/react-native-windows/docs/native-modules-setup#creating-a-new-native-module-library-project) or you can just [add your Windows Runtime Component to your React Native for Windows solution](https://microsoft.github.io/react-native-windows/docs/native-modules-setup#referencing-windows-apis-within-a-react-native-for-windows-project). The first approach is suggested if you're planning to share your module and reuse it with multiple projects; the second one is good if it's a one-time module you're planning to use only with the app you're building.\n\nThe documentation on the official website is very clear and detailed, so I won't repeat the steps in this article. I'm going to use a C# Windows Runtime Component, since it's the language I'm more familiar with, but you can do the same with C++.\n\n### Create a custom control\n\nThe first step is to create a user control which we want to make available to the JavaScript layer via JSX. You can choose to create the control in code or via XAML. In this article, I will guide you through the XAML approach, so right click on the Windows Runtime Component, choose **Add -> New item**, select the **User Control** template and give it a meaningful name, like `InkCanvasControl.xaml`.\n\nYou can start working on the look & feel of the User Control in the XAML file, based on your requirements. We could just add an `InkCanvas` control for our purpose but, for the sake of showing a more realistic scenario, let's make the UI slightly more complex:\n\n```xml\n<UserControl\n    x:Class=\"InkCanvasModule.InkCanvasControl\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:InkCanvasModule\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\"\n    d:DesignHeight=\"300\"\n    d:DesignWidth=\"400\">\n\n    <Grid>\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"50\" />\n            <RowDefinition Height=\"*\" />\n        </Grid.RowDefinitions>\n        <TextBlock Text=\"{x:Bind Path=Title}\" Style=\"{StaticResource HeaderTextBlockStyle}\" \n                   Grid.Row=\"0\" HorizontalAlignment=\"Center\" />\n        <InkCanvas x:Name=\"MyInkCanvas\" Width=\"1000\" Height=\"1000\" Grid.Row=\"1\"  />\n    </Grid>\n</UserControl>\n```\n\nThe `InkCanvas` control is placed inside a `Grid` together with a `TextBlock` control, which is used to display a header. Exactly like we would do with a standard User Control, the title isn't fixed, but it's connected to a dependency property via binding. This enables us, as developers, to customize the title when we add the User Control to a page. In the React Native context, this is is the first step to expose the property to JSX, so that we can customize the look & feel of the control directly in JavaScript.\n\nIn the code behind of the control we have, of course, to define `Title` as a dependency property:\n\n```csharp\npublic string Title\n{\n    get { return (string)GetValue(TitlePropertyField); }\n    set { SetValue(TitlePropertyField, value); }\n}\n\n// Using a DependencyProperty as the backing store for Title.  This enables animation, styling, binding, etc...\nprivate static readonly DependencyProperty TitlePropertyField =\n    DependencyProperty.Register(\"Title\", typeof(string), typeof(InkCanvasControl), new PropertyMetadata(string.Empty));\n\ninternal static DependencyProperty TitleProperty\n{\n    get\n    {\n        return TitlePropertyField;\n    }\n}\n```\n\nThe last change to do in the code behind is adding the following line in the public constructor:\n\n```csharp\npublic InkCanvasControl()\n{\n    this.InitializeComponent();\n    MyInkCanvas.InkPresenter.InputDeviceTypes = Windows.UI.Core.CoreInputDeviceTypes.Mouse | Windows.UI.Core.CoreInputDeviceTypes.Touch | Windows.UI.Core.CoreInputDeviceTypes.Pen;\n}\n```\n\nThis will enable the canvas to receive ink inputs from multiple devices, including mouse, which is especially useful during testing if you don't have a pen-enabled device.\n\n### Expose the user control to React Native\n\nSo far, we didn't do anything related to React Native. We built a User Control in the same way we would do for a traditional UWP application. To expose it to React Native and use the control in JSX we need to add a new class to our Windows Runtime Component which will wrap the User Control in a View Manager.\nRight click on the Windows Runtime Component, choose **Add -> Class** and give it a meaningful name (a common convention is the name of the control followed by the `ViewManager` suffix, like `InkCanvasControlViewManager.cs`).\nThe class must be marked as `internal` and inherit from `AttributedViewManager<T>`, where `T` is the user control. For example, this is how it looks like for the `InkCanvasControl` we have previously created:\n\n```csharp\nusing Microsoft.ReactNative.Managed;\n\nnamespace InkCanvasModule\n{\n    internal class InkCanvasControlViewManager: AttributedViewManager<InkCanvasControl>\n    {\n        //add code here \n    }\n}\n```\n\nNow we are ready to expose native features of the user control to the JavaScript layer. The React Native for Windows SDK enables us to expose multiple elements:\n\n- **Properties**, which can be used to customize the user control.\n- **Commands**, which can be used to interact with the user control.\n- **Events**, which can be used to react to changes in the user control.\n\nIn the following sections we're going to see how to implement all three scenarios. But before doing that, let's see how we can expose the native control to JavaScript.\nThe process is the same you would follow [for a native module](https://microsoft.github.io/react-native-windows/docs/native-modules-setup). First, you have to add a new class to your Windows Runtime Component called `ReactPackageProvider`, which must have the following implementation:\n\n```csharp\nusing Microsoft.ReactNative;\n\nnamespace InkCanvasModule\n{\n    public partial class ReactPackageProvider : IReactPackageProvider\n    {\n        public void CreatePackage(IReactPackageBuilder packageBuilder)\n        {\n            CreatePackageImplementation(packageBuilder);\n        }\n\n        /// <summary>\n        /// This method is implemented by the C# code generator\n        /// </summary>\n        partial void CreatePackageImplementation(IReactPackageBuilder packageBuilder);\n    }\n}\n```\n\nThen you have to register the module with your main React Native application. If you're building this component as a dedicated native module, you can leverage [autolinking](https://microsoft.github.io/react-native-windows/docs/native-modules-autolinking) to do everything automatically. If, instead, you have added the component as a project to an existing React Native for Windows solution, you can follow [the manual linking](https://microsoft.github.io/react-native-windows/docs/native-modules-using) approach.\n\nOnce the native module is linked, you can reference it in JavaScript using the `requireNativeComponent()` function:\n\n```javascript\nimport {requireNativeComponent} from 'react-native'\n\nconst InkCanvas = requireNativeComponent('InkCanvasControl')\n```\n\nAs parameter, you have to pass the name of the class which defines the User Control you have previously created (`InkCanvasControl`, in our example).\nFrom now on, you will be able to reference the control in JSX using the `InkCanvas` constant, like in the following example:\n\n```javascript\nclass App extends React.Component {\n\n  render(){\n    return (\n      <View>\n        <InkCanvas style={{ width: 1000, height: 1000}} />\n      </View>\n    );\n  }\n};\n```\n\n### Enabling the InkCanvas control in a React Native for Windows app\n\nIf you test the implementation so far, you will notice that the header will be rendered fine, but the `InkCanvas` won't work. The reason can be found [in the documentation](https://microsoft.github.io/react-native-windows/docs/view-managers#note-about-uwp-xaml-controls):\n\n> Some UWP XAML controls do not support being hosted in environments where 3D transforms are involved (i.e. the Transform3D property is set on the control or on any of the control's ancestors in the XAML tree).\nCurrently, React Native for Windows uses a global PerspectiveTransform to provide a 3D look to objects being rotated along the x or y axes, which means these controls that do not work in 3D environments, will not work out of the box.\n\n`InkCanvas` is exactly one of these controls that doesn't work in a 3D environment. React Native for Windows offers us a workaround which, however, is supported only starting from version 0.64. \nAs the documentation explains, React Native for Windows supports an experimental feature to disable the 3D perspective. Open the `MainPage.xaml` file in your React Native project, in which you'll find the `ReactRootView` control which hosts the React Native content. Add a new property to the control called `IsPerspectiveEnabled` and set it to `False`. This is how the control should look like:\n\n```xml\n<react:ReactRootView \n    x:Name=\"reactRootView\"\n    ComponentName=\"InkCanvasv064\"\n    IsPerspectiveEnabled=\"False\"\n    Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\"\n    MinHeight=\"400\"/>\n```\n\nThat's it. Now we can continue the implementation of the features of our custom control.\n\n### Exposing a property\n\nThis isn't stricly related to enable inking, but it's a good learning when it comes to build native UI modules. The goal of this section is to expose the dependency property called `Title` that we have created to JavaScript, so that we can customize it using JSX. Properties can be exposed using the `ViewManagerProperty` attribute, like in the following sample:\n\n```csharp\n[ViewManagerProperty(\"title\")]\npublic void SetTitle(InkCanvasControl view, string value)\n{\n    if (null != value)\n    {\n        view.Title = value;\n    }\n    else\n    {\n        view.ClearValue(InkCanvasControl.TitleProperty);\n    }\n}\n```\n\nThe method, called `SetTitle()`, is decorated with the `ViewManagerProperty` attribute, which sets the name that will be used to expose the property to JSX (in this case, it's `title` in lowercase, to follow the JavaScript naming conventions).\nThe method receives, as input, a reference to the user control and the value assigned via JSX. The implementation of the method is straigthforward: if the property assigned in JSX has a value, we assign it to the `Title` property of the user control; otherwise, we clear it.\n\nNow we'll be able to leverage the `title` property in our React Native components, like in the following sample:\n\n```javascript\nclass App extends React.Component {\n\n  render(){\n    return (\n      <View>\n        <InkCanvas style={{ width: 1000, height: 1000}}\n                   title=\"Hello world!\" />\n      </View>\n    );\n  }\n};\n```\n\nAnd this is the final result:\n\n![](assets/2021-05-25-inking/HelloWorld.png)\n\n### Exposing a command\n\nOne of the most common features that developers want to implement when they work with inking is the ability to save the content of the `InkCanvas` control as an image. To enable this feature we're going to implement a command. The concept is very similar to exposing a method in a React Native module and it will enable us to trigger, from JavaScript, the native APIs exposed by the `InkCanvas` control to render the ink into a stream.\n\nThe first step is to install a library called [Win2D](https://github.com/microsoft/Win2D), which enables advanced 2D operations in a UWP app. Thanks to this library, we'll be able to render the content of the canvas into a stream that we can save into a file. To install it, right click on your Windows Runtime Component, choose **Manage NuGet Packages** and look for the [Win2D package](https://www.nuget.org/packages/Win2D.uwp/).\n\nThe command is defined using the `ViewManagerCommand` attribute which, like in the previous section, accepts a parameter that specifies the name of the method that will be exposed to JavaScript. This is the full implementation:\n\n```csharp\n[ViewManagerCommand(\"saveInkToFile\")]\npublic async Task SaveInkToFile(InkCanvasControl view, IReadOnlyList<string> commandArgs)\n{\n    string fileName = commandArgs[0].ToString();\n\n    var inkCanvas = view.FindName(\"MyInkCanvas\") as InkCanvas;\n\n    CanvasDevice device = CanvasDevice.GetSharedDevice();\n    CanvasRenderTarget renderTarget = new CanvasRenderTarget(device, (int)inkCanvas.ActualWidth, (int)inkCanvas.ActualHeight, 96);\n\n    using (var ds = renderTarget.CreateDrawingSession())\n    {\n        ds.Clear(Colors.White);\n        ds.DrawInk(inkCanvas.InkPresenter.StrokeContainer.GetStrokes());\n    }\n\n    FileSavePicker fileSavePicker = new FileSavePicker();\n    fileSavePicker.FileTypeChoices.Add(\"Image\", new List<string>() { \".jpg\" });\n    fileSavePicker.SuggestedFileName = fileName;\n    var file = await fileSavePicker.PickSaveFileAsync();\n\n    using (var fileStream = await file.OpenAsync(FileAccessMode.ReadWrite))\n    {\n        await renderTarget.SaveAsync(fileStream, CanvasBitmapFileFormat.Jpeg, 1f);\n    }\n}\n```\n\nThe method receives, as input, a reference to the user control and a series of parameters that the JavaScript app can pass to it. In our scenario, we're getting from the JavaScript layer the default name of the file that is suggested when you save the image.\nThe method performs the following actions:\n\n1) It retrieves a reference to the `InkCanvas` control included in the User Control, using the `FindName()` method.\n2) It creates a `CanvasRenderTarget` to store the inking session, which is exposed by the `InkPresenter` property of the `InkCanvas` control.\n3) It uses the `FileSavePicker` API to prompt to the user where he/she/they want to save the image. Once we have a reference to the destination file, we use the `SaveAsync()` method of the `CanvasRenderTarget` object to save the stream.\n\nIn this scenario, we can use a simple command because we are interacting with the User Control, but we aren't expecting anything in return. The content of the `InkCanvas` will be just saved to a file and then the operation will be considered completed.\n\nNow we can leverage the command directly in JavaScript, as in the following example:\n\n```javascript\nclass App extends React.Component {\n\n  saveInk = () => {\n    if (this._inkCanvasRef) {\n      const tag = findNodeHandle(this._inkCanvasRef);\n      UIManager.dispatchViewManagerCommand(tag, UIManager.getViewManagerConfig('InkCanvasControl').Commands.saveInkToFile, ['ink.jpg']);\n    }\n  }\n\n  render(){\n    return (\n      <View>\n        <Button title=\"Save ink\" onPress={() => {this.saveInk(); }} />\n\n        <InkCanvas ref={(ref) => { this._inkCanvasRef = ref;}}\n                   style={{ width: 1000, height: 1000}}\n                   title=\"Hello world!\" \n                   />\n      </View>\n    );\n  }\n};\n```\n\nAs first step, we have to use the `ref` property to store a reference to the `InkCanvas` control in JSX. Then, we can use this reference to create a function that will invoke our command by using the `UIManager.dispatchViewManagerCommand()` function. It requires as input:\n\n1) The tag associated to the `InkCanvasControl`, which we get by calling the `findNodeHandle()` method with the reference we have previously stored.\n2) The command to execute, which is exposed by the `UIManager.getViewManagerConfig().Commands` function. There are two key concept here to highlight: the parameter we pass to the `getViewManagerConfig()` method is the name of the class which hosts our User Control (`InkCanvasControl`); the `Commands` property, instead, exposes all our commands using the name we have passed to the `ViewManagerCommand` attribute (in this case, we're using the `saveInkToFile` one).\n3) This is optional. If your command accepts one or more arguments coming from the JavaScript layer. you can pass them here as an array. In our scenario, we are passing the default name of the image that will be used by the `FileSavePicker` APIs.\n\nNow that we have defined a JavaScript function, we can just connect it to the `onPress` event of a `Button` control. When you press the button, this is what you're going to see:\n\n![](assets/2021-05-25-inking/FileSavePicker.png)\n\nThe picker will show up and will ask you where you want to save the image. Once the operation is completed, you will find in that location an image with the content of the `InkCanvas` control.\n\n### Exposing an event handler\n\nAnother common inking scenario is the requirement to save the content of the canvas, but not as a file on the device, but as as base64 encoded string. This enables developers to send the image, for example, to a cloud service for further processing.\nThe APIs we need to use in the native layer are almost the same as the previous scenario. However, in this case, there's an important difference: it isn't anymore a fire & forget command, but we need to get a result back.\n\nCommands don't directly support the option to return a value. However, for these scenarios we can use **events**. We'll trigger a command to save the content of the canvas as a base64 image and then we'll raise an event, passing the image as parameter. In JavaScript, we'll subscribe to this event so that we can receive the base64 image when it's ready.\n\nEvents are implemented using the `ViewManagerEvent` class and they are decorated with the `ViewManagerExportedDirectEventTypeConstant` attribute:\n\n```csharp\n[ViewManagerExportedDirectEventTypeConstant]\npublic ViewManagerEvent<InkCanvasControl, string> InkSaved = null;\n```\n\nThe event is defined as a `ViewManagerEvent<T, Y>`, where `T` is the name of the class which will raise the event (our user control), while `Y` is the type of the data that will be returned (the `string` which contains the image encoded in base64).\n\nNow we can define our command using, again, the `ViewManagerCommand` attribute:\n\n```csharp\n[ViewManagerCommand(\"saveInkToBase64\")]\npublic async Task SaveInkToBase64(InkCanvasControl view, IReadOnlyList<object> commandArgs)\n{\n    var inkCanvas = view.FindName(\"MyInkCanvas\") as InkCanvas;\n\n    string base64String = string.Empty;\n\n    CanvasDevice device = CanvasDevice.GetSharedDevice();\n    CanvasRenderTarget renderTarget = new CanvasRenderTarget(device, (int)inkCanvas.ActualWidth, (int)inkCanvas.ActualHeight, 96);\n\n    using (var ds = renderTarget.CreateDrawingSession())\n    {\n        ds.Clear(Colors.White);\n        ds.DrawInk(inkCanvas.InkPresenter.StrokeContainer.GetStrokes());\n    }\n\n    using (InMemoryRandomAccessStream stream = new InMemoryRandomAccessStream())\n    {\n        await renderTarget.SaveAsync(stream, CanvasBitmapFileFormat.Jpeg);\n        var reader = new DataReader(stream.GetInputStreamAt(0));\n        await reader.LoadAsync((uint)stream.Size);\n        byte[] byteArray = new byte[stream.Size];\n        reader.ReadBytes(byteArray);\n        base64String = Convert.ToBase64String(byteArray);\n    }\n\n    InkSaved?.Invoke(view, base64String);         \n}\n```\n\nThe core of the implementation is the same as the previous one. The main difference is that, instead of using the `FileSavePicker` APIs, we're storing the content of the canvas in an `InMemoryRandomAccessStream` object. Then, using the `DataReader` class, we read the stream and we convert it into a base64 string.\nIn the end, we raise the event we have previously created with the `Invoke()` method, passing as parameter the reference to the `InkCanvasControl` that we have and the base64 string we have just created.\n\nLet's see now how we can use the event in JavaScript:\n\n```javascript\nclass App extends React.Component {\n\n  saveInkToBase64 = () => {\n    if (this._inkCanvasRef) {\n      const tag = findNodeHandle(this._inkCanvasRef);\n      UIManager.dispatchViewManagerCommand(tag, UIManager.getViewManagerConfig('InkCanvasControl').Commands.saveInkToBase64);\n    }\n  }\n\n  onGetInk = (result) => {\n    var image = 'data:image/png;base64,' + result.nativeEvent;\n    console.log(image);\n  }\n\n  render(){\n    return (\n      <View>\n        <Button title=\"Save ink to base64\" onPress={ () => {this.saveInkToBase64();}} />\n        <InkCanvas ref={(ref) => { this._inkCanvasRef = ref;}}\n                   style={{ width: 1000, height: 1000}}\n                   title=\"Hello world!\"\n                   onInkSaved={(evt) => {this.onGetInk(evt); }} />\n      </View>\n    );\n  }\n};\n```\n\nThe implementation of the command is the same we have seen in the previous section. The difference is that, this time, the `InkCanvas` control in JSX exposes also an `onInkSaved` event, that we can subscribe.\nThe subscription is handled by the `onGetInk()` function which receives, as parameter, the image in base64 returned by the native module. When the user presses the button, React Native will trigger the `saveInkToBase64` command exposed by the control. Once the generation of the image encoded in a base64 string is completed in the native layer, the `onInkSaved` event will be raised and the `onGetInk()` function will be executed.\n\nIn this example we're just showing the base64 string in the debugger console, but we could also set it as source of an `Image` control to display it, like in the example below:\n\n![](assets/2021-05-25-inking/base64string.png)\n\n### Wrapping up\n\nIn this article we have learned how to enable inking features in our React Native for Windows application, by wrapping the `InkCanvas` control in a native UI module. However, the lessons we have learned aren't specific to the inking scenario, but they can be applied anytime you have a native Windows control that it isn't directly supported by React Native but that you would like to use in your applications.\n\nI would like to thank [Alexander Sklar](https://twitter.com/alexsklar) for the guidance he provided during the implementation of this feature.\n\nYou can find the sample project used in this article [on GitHub](https://github.com/qmatteoq/rnw-inkcanvas)."
    },
    {
      "id": "/2021/05/17/codepush",
      "metadata": {
        "permalink": "/react-native-windows/blog/2021/05/17/codepush",
        "source": "@site/blog/2021-05-17-codepush.md",
        "title": "Using CodePush in a React Native for Windows application",
        "description": "How to use CodePush to deliver real-time updates to your React Native for Windows application",
        "date": "2021-05-17T00:00:00.000Z",
        "formattedDate": "May 17, 2021",
        "tags": [],
        "readingTime": 15.655,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Matteo Pagani",
            "url": "https://twitter.com/ReactNativeMSFT"
          }
        ],
        "frontMatter": {
          "title": "Using CodePush in a React Native for Windows application",
          "author": "Matteo Pagani",
          "authorURL": "https://twitter.com/ReactNativeMSFT",
          "description": "How to use CodePush to deliver real-time updates to your React Native for Windows application",
          "is_blog": true,
          "published_date": "May 17, 2021"
        },
        "prevItem": {
          "title": "Add inking to your React Native for Windows application",
          "permalink": "/react-native-windows/blog/2021/05/25/inking"
        },
        "nextItem": {
          "title": "Gallery App, TurboModules, and more community modules",
          "permalink": "/react-native-windows/blog/2021/03/16/64updates"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/rnw-codepush/\" />\n</head>\n\nCodePush is a service built by Microsoft, now incorporated into the [Visual Studio App Center platform](https://appcenter.ms/), which provides a way for React Native and Cordova developers to be more agile in delivering updates to their applications.\nThanks to CodePush, you are able to deliver a new bundle (which might contain updated JavaScript files, new images, etc.) without having to fully redeploy a new package. This means, for example, that you can update the content of your application published on a Store without submitting a new package and waiting for the certification process to be completed; or that you can add a new feature in your LOB app without having to redeploy it via Intune or another MDM solution to all your employees.\n\n<!--truncate-->\n\nThe only caveat is that **the feature works only for updates which involves the bundle**, which means changes in the JavaScript code, a new asset, etc. If the update involves changes in the binary package (like adding a new capability in the manifest or integrating a new native module), then you are required to submit a new package using the standard approach. \n\nEnabling Code Push requires to interact with three different layers:\n\n1. App Center, which is the cloud platform that will host and deliver your updates. You're going to push new bundles to App Center using the [App Center CLI](https://docs.microsoft.com/appcenter/cli/).\n2. A native module, which must be integrated in the React Native application.\n3. A set of JavaScript APIs, which you must integrate in the JavaScript layer of your application to manage the update lifecycle.\n\nCodePush initially supported only iOS and Android, but [the native module](https://github.com/microsoft/react-native-code-push/) has recently added support for the Windows implementation of React Native as well. However, App Center still lacks support for this technology on Windows and, today, when you create a new Windows application on App Center, React Native isn't one of the available options. This means that the infrastructure needed to support CodePush won't be available. In this article we're going to see how we can configure our Windows application to use Code Push, even if it isn't fully supported by App Center.\n\n## Setting up App Center\n\nThe first task is to create a new application in Visual Studio App Center. Thes starting point is the [App Center website](https://appcenter.ms/), where you can login to your dashboard. If you don't already have an account, you can create a free one the first time you login using your Microsoft Account, work account, GitHub, Facebook or Google account.\nOnce you are logged in, click on **Add new** and choose **Add new app**.\n\nThis is the first step where we have to apply a workaround. In this panel, you will be able to setup your application, by specifing the name and the target platform:\n\n![](assets/2021-05-17-codepush/NewApp.png)\n\nHowever, as previously mentioned, if you choose **Windows** you won't see React Native as an option. As such, we have to trick App Center to think that our Windows application is actually an Android one.\n\n> The process will work also if you choose iOS. Since we won't really use any specific Android or iOS SDK, it doesn't really matter, as long as React Native is a supported platform.\n\nAs such, choose **Android** as OS and **React Native** as Platform, then create the application. Since you have chosen React Native, you should see now a section called **CodePush** in the Distribute section:\n\n![](assets/2021-05-17-codepush/CodePush-AppCenter.png)\n\nIn CodePush you can configure multiple deployments slot, to manage different versions of the application (production, staging, etc.). By clicking on **Create standard deployments** App Center will create by defaults two environments: Staging and Production. By clicking on the wrench icon at the top, you will be able to add new ones. \nEach environment has a dedicated key, which is required to setup CodePush in the application. For the moment, let's assume that we're going to work with the staging version of the app, so copy the key for that environment and keep it for the next steps.\n\n![](assets/2021-05-17-codepush/Environments.png)\n\nThe last step is to install the App Center CLI, which provides the commands you will need to push the bundle updates to the App Center servers. To install it, open a prompt on your machine and run the following command:\n\n```powershell\nnpm install -g appcenter-cli\n```\n\nBefore moving to the next step, run the following command to login with your App Center account and connect the CLI to it:\n\n```powershell\nappcenter login\n```\n\nNow we can start integrating the SDK in our React Native app.\n\n## Integrating the SDK\n\nThe SDK is available as a React Native native module, which fully supports autolinking on Windows as well. As such, the first step is to install the module. Move to the root of your React Native project and run the following command in a terminal:\n\n```powershell\nyarn add react-native-code-push\n```\n\nThe next step is to perform the autolinking. We have to do it manually because, after the module has been linked, we'll have to make some manual changes to the app before being able to build and deploy it. As such, from the same root of the project, run the following command:\n\n```powershell\nnpx react-native autolink-windows\n```\n\nNow open in Visual Studio the solution in the **windows** folder (it will have the same name of your project, plus the .sln extension).\nIf you have performed the autolinking properly, the solution will look like this:\n\n![](assets/2021-05-17-codepush/SolutionExplorer.png)\n\nIn the previous image, **codepushsample** is the main application which acts as a React Native host (in this case it's based on C#, but it can be C++ as well), while **CodePush** is the SDK referenced by the main app.\nThe next step is to change the implementation of the `OnLaunched` event, which takes care of initializing the app. **This is a very important step**: it won't be enough to add the code to initialize CodePush, but you have also to make the below changes in the initialization; otherwise, the application won't behave properly and, most of the times, launching it will result in a blank screen or a frozen app.\n\nIf you have opted for an host application based on C# (so you have initialized React Native for Windows with the `--language cs` parameter), you will find the `OnLaunched` implementation in the `App.xaml.cs` file. You will have to replace it with the following code:\n\n```csharp\nprotected override void OnLaunched(LaunchActivatedEventArgs e)\n{\n    Microsoft.CodePush.ReactNative.CodePushConfig.SetHost(Host);\n    Dictionary<string, string> configMap = new Dictionary<string, string>();\n    configMap.Add(\"appVersion\", \"1.0.0\");\n    configMap.Add(\"deploymentKey\", \"<deploymentKey>\");\n    Microsoft.CodePush.ReactNative.CodePushConfig.Init(configMap);\n\n    Frame rootFrame = null;\n\n    var content = Window.Current.Content;\n    if (content != null)\n    {\n        rootFrame = content as Frame;\n    }\n\n    if (rootFrame == null)\n    {\n        rootFrame = new Frame();\n        if (e.PreviousExecutionState == ApplicationExecutionState.Terminated)\n        {\n\n        }\n\n        if (!e.PrelaunchActivated)\n        {\n            if (rootFrame.Content == null)\n            {\n                rootFrame.Navigate(typeof(MainPage), e.Arguments);\n            }\n\n            Window.Current.Content = rootFrame;\n            Window.Current.Activate();\n        }\n    }\n    else\n    {\n        if (!e.PrelaunchActivated)\n        {\n            if (rootFrame.Content == null)\n            {\n                rootFrame.Navigate(typeof(MainPage), e.Arguments);\n            }\n\n            Window.Current.Activate();\n        }\n    }\n}\n```\n\nIf, instead, you're using a C++ host (the default one), you will find the implementation in the **App.cpp** file. This is the new implementation you have to provide:\n\n```cpp\nvoid App::OnLaunched(activation::LaunchActivatedEventArgs const& e)\n{\n    winrt::Microsoft::CodePush::ReactNative::CodePushConfig::SetHost(Host());\n    auto configMap{ winrt::single_threaded_map<hstring, hstring>() };\n    configMap.Insert(L\"appVersion\", L\"1.0.0\");\n    configMap.Insert(L\"deploymentKey\", L\"<deploymentKey>\");\n    winrt::Microsoft::CodePush::ReactNative::CodePushConfig::Init(configMap);\n\n    Frame rootFrame{ nullptr };\n    auto content = Window::Current().Content();\n    if (content)\n    {\n        rootFrame = content.try_as<Frame>();\n    }\n\n    // Do not repeat app initialization when the Window already has content,\n    // just ensure that the window is active\n    if (rootFrame == nullptr)\n    {\n        // Create a Frame to act as the navigation context and associate it with\n        // a SuspensionManager key\n        rootFrame = Frame();\n\n        rootFrame.NavigationFailed({ this, &App::OnNavigationFailed });\n\n        if (e.PreviousExecutionState() == ApplicationExecutionState::Terminated)\n        {\n            // Restore the saved session state only when appropriate, scheduling the\n            // final launch steps after the restore is complete\n        }\n\n        if (e.PrelaunchActivated() == false)\n        {\n            if (rootFrame.Content() == nullptr)\n            {\n                // When the navigation stack isn't restored navigate to the first page,\n                // configuring the new page by passing required information as a navigation\n                // parameter\n                rootFrame.Navigate(xaml_typename<CodePushDemoAppCpp::MainPage>(), box_value(e.Arguments()));\n            }\n            // Place the frame in the current Window\n            Window::Current().Content(rootFrame);\n            // Ensure the current window is active\n            Window::Current().Activate();\n        }\n    }\n    else\n    {\n        if (e.PrelaunchActivated() == false)\n        {\n            if (rootFrame.Content() == nullptr)\n            {\n                // When the navigation stack isn't restored navigate to the first page,\n                // configuring the new page by passing required information as a navigation\n                // parameter\n                rootFrame.Navigate(xaml_typename<CodePushDemoAppCpp::MainPage>(), box_value(e.Arguments()));\n            }\n            // Ensure the current window is active\n            Window::Current().Activate();\n        }\n    }\n}\n```\n\nYou can copy and paste both snippets of code as they are. The only change to apply is in the first lines, where the CodePush initialization happens:\n\n```csharp\nMicrosoft.CodePush.ReactNative.CodePushConfig.SetHost(Host);\nDictionary<string, string> configMap = new Dictionary<string, string>();\nconfigMap.Add(\"appVersion\", \"1.0.0\");\nconfigMap.Add(\"deploymentKey\", \"<deploymentKey>\");\nMicrosoft.CodePush.ReactNative.CodePushConfig.Init(configMap);\n```\n\n`appVersion` is the version number of the application and it's used to determine if CodePush should deliver an update or not for this version. When you publish a bundle on CodePush, in fact, you can specify which is the version of the application the bundle refers to, so that only users with that version will receive the update. `deploymentKey`, instead, is the key we have previously retrieved from App Center.\n\nThat's it. Now you can deploy and run the application like a normal React Native for Windows application. You won't see any changes for the moment. \nHowever, be aware that, in order to test the implementation, **you won't be able to use a debug version of the app**, but you will have to generate a release AppX / MSIX package and deploy it on your machine.\nThe reason is that, when you're debugging a React Native application, the Metro packager is always up & running. As such, any change you're going to make to the JavaScript layer will be automatically pushed to the host app and displayed in real time, without giving you the possibility to push it as an update via CodePush.\n\nTo generate a relase version of the package, you can follow [this guidance](https://microsoft.github.io/react-native-windows/docs/getting-started#building-a-standalone-react-native-windows-app).\n\n**Important!** Before generating a release package, open the manifest of the app (double click on the Package.appxmanifest file in Visual Studio), move to the **Packaging** section and change the **Package name** field to a more friendly name.\nBy default, the package name assigned to a new UWP app is a GUID, which makes the **Package Family Name** (the unique identifier of a packaged app) very long. Since the Package Family Name is used also to generate the folder where Windows stores the local data (including the updates downloaded from App Center), a very long name could lead CodePush to break and you might get errors like `The filename or extension is too long` when the updated bundle is being installed.\n\n## Integrating the JavaScript APIs\n\nNow we are ready to start setting up CodePush in the JavaScript layer of the application. The key to enable it is to wrap the main `App` class or function (based on the approach you're using) inside the `codePush` one, like in the following examples:\n\n```javascript\n//class component\nimport codePush from \"react-native-code-push\";\n\nclass App extends Component {\n    // your app component\n}\n\nApp = codePush(App);\n\nexport default App;\n\n//functional component\nimport codePush from \"react-native-code-push\";\n\nlet App: () => React$Node = () => {\n    //your app component\n}\n\nApp = codePush(App);\n\nexport default App;\n```\n\nWith this basic configuration you enable the default behavior: CodePush will search for updates when the application starts and, if they're available, it will download them silently and apply them at the next restart.\nLet's try it. As first step, after you have wrapped your application in the `codePush` function, you will have to generate, through Visual Studio, a new MSIX / AppX package compiled in Release mode and then install it on your machine.\nOnce you have it, you can start making changes to your application. Feel free to change anything which involves the JavaScript layer: a text, a style, a component, etc.\n\nOnce you have made the change, you will need to create a new bundle and release it on CodePush. If you follow the official guidance, you'll find that the App Center CLI has a special command called `release-react` which automatically takes care of generating the bundle and pushing it to CodePush. However, at the time of writing, the App Center CLI doesn't support Windows as a platform yet. As such, the `release-react` will generate an incorrect bundle: since, in App Center, you have configured this app as an Android app, it will generate an Android bundle.\n\nThe workaround is to manually generate the bundle for Windows and then manually upload it to CodePush, using the `release` command. Let's start with the first step. Open a terminal on the root of your project and create a folder called `Bundle` to store it:\n\n```powershell\nmkdir Bundle\n```\n\nThen run the following command:\n\n```powershell\nnpx --no-install react-native bundle --platform windows --entry-file index.js --bundle-output ./Bundle/index.windows.bundle --assets-dest ./Bundle --dev false --reset-cache\n```\n\nThis is the same command that Visual Studio runs when you generate a release package for the Windows application.\nNow you can push it to App Center using the App Center CLI with the following command:\n\n```powershell\nappcenter codepush release -a mpagani/CodePushSample -c .\\Bundle -t 1.0.0\n```\n\nThis is the meaning of the various parameters:\n\n- `-a` is the identifier of application you have registed on App Center. The parameter is made by the name of your account / the name of the application. You can find them in your URL of your browser, when you have the dashboard opened on the app:\n\n    ![](assets/2021-05-17-codepush/url.png)\n\n- `-c` is the path which contains the bundle you want to publish. In our case, it's the `Bundle` folder which we have previously created.\n- `-t` is the version number of the app this bundle refers to.\n\nAfter a few seconds, you should see a confirmation that the bundle has been succesfully uploaded. You can check that the operation was succesfull by logging in to the App Center dashboard of your application. You should see all the releases you have published in the CodePush section:\n\n![](assets/2021-05-17-codepush/CodePush-Releases.png)\n\nYou will be able to see different statistics about each release, like the number of users who have downloaded and installed the update:\n\n![](assets/2021-05-17-codepush/ReleaseDetail.png)\n\nNow you should be able to see CodePush in action by following these steps:\n\n1. Open the application you have previously packaged and deployed.\n2. You will see the original version of the application. However, in background, CodePush will have started to download the new bundle.\n3. Close and reopen the application.\n4. Now you should see the new version of the application, with the changes you have applied.\n\n### Configure the update\nWhen you use the CLI, you can also configure how the update should behave with different parameters. For example, if it's a mandatory update (so the user can't ignore it or postpone it), you can use the `--mandatory` parameter:\n\n```powershell\nappcenter codepush release -a mpagani/CodePushSample -c .\\Bundle -t 1.0.0 --mandatory\n```\n\nAlternatively, if you want to enable a gradual rollout, you can use the `--rollout` parameter with a number between 1 and 100, which represents the percentage of users that will receive the update immediately:\n\n```powershell\nappcenter codepush release -a mpagani/CodePushSample -c .\\Bundle -t 1.0.0 --rollout 25\n```\n\nYou can find all the parameters documented [here](https://github.com/microsoft/code-push/tree/v3.0.1/cli#releasing-updates-general). In case you have already pushed an update and you want to change its configuration, you can use the App Center dashboard. By clicking on the wrench icon inside a release page, you will be able to customize it:\n\n![](assets/2021-05-17-codepush/ConfigureUpdate.png)\n\n## Customizing the update behavior\n\nThe CodePush APIs give you lot of flexibility in deciding how you want to manage updates. The previous implementation you have tested is the default one, but there are other alternatives.\n\n### Show a prompt to the user\n\nWith this approach, the check for updates still happens when the application starts, but the package won't be automatically downloaded and installed. The user will be prompted if they want to move on or cancel it (unless it was marked as mandatory when you have published the bundle).\n\n![](assets/2021-05-17-codepush/UpdatePrompt.png)\n\nTo achieve this goal, you can pass the following options when you initialize the `codePush` function:\n\n```javascript\nimport codePush from \"react-native-code-push\";\n\nlet App: () => React$Node = () => {\n    //your app component\n}\n\nApp = codePush({ updateDialog: true, installMode: codePush.InstallMode.IMMEDIATE })(App);\n\nexport default App;\n```\n\n### Handle updates manually\n\nYou can also choose to disable automatic updates and provide a manual way to the user to check and install them, for example via a button. The first step is to pass `CheckFrequency.MANUAL` as option in the `codePush()` function to disable automatic updates:\n\n```javascript\nimport codePush from \"react-native-code-push\";\n\nlet App: () => React$Node = () => {\n    //your app component\n}\n\nApp = codePush({ checkFrequency: codePush.CheckFrequency.MANUAL })(App);\n\nexport default App;\n```\n\nThen you can use use the `sync()` function provided by the CodePush APIs to manually trigger the update check. You can call this function, for example, when a button is pressed:\n\n```javascript\nconst onCheckUpdates = async () => {\n  var result = await codePush.sync({\n      updateDialog: true,\n      installMode: codePush.InstallMode.IMMEDIATE\n  });\n}\n```\n\n### Track the download progress\n\nCodePush provides a series of events to track the status of the installation. The only caveat is that, at the moment of writing, they are exposed only through class components.\nThis is an example of the implementation:\n\n```javascript\nclass App extends React.Component {\n    codePushStatusDidChange(status) {\n        switch(status) {\n            case codePush.SyncStatus.CHECKING_FOR_UPDATE:\n                console.log(\"Checking for updates.\");\n                break;\n            case codePush.SyncStatus.DOWNLOADING_PACKAGE:\n                console.log(\"Downloading update.\");\n                break;\n            case codePush.SyncStatus.INSTALLING_UPDATE:\n                console.log(\"Installing update.\");\n                break;\n            case codePush.SyncStatus.UP_TO_DATE:\n                console.log(\"Your app is up-to-date.\");\n                break;\n            case codePush.SyncStatus.UPDATE_INSTALLED:\n                console.log(\"Update installed.\");\n                break;\n        }\n    }\n\n    codePushDownloadDidProgress(progress) {\n        console.log(progress.receivedBytes + \" of \" + progress.totalBytes + \" received.\");\n    }\n}\nApp = codePush(MyApp);\nexport default App;\n```\n\nThe `codePushStatusDidChange()` event is raised when the status of the update changes. It can assume one of the values exposed by the `SyncStatus` enumerator. The `codePushDownloadDidProgress()` event, instead, is raised when the download has started and, through the `progress` object, you can get the current status, in case you want to display a progress bar or another similar control.\n\n## Wrapping up\n\nThanks to CodePush, you can be more agile in keeping your application up-to-date and deliver new features without having to redeploy a completely new package. Currently, a few workarounds are needed for App Center to integrate with the React Native for Windows implementation. I highly recommend you to read [the whole README of the main repository](https://github.com/microsoft/react-native-code-push/blob/master/README.md), since it contains a lot of additional information for advanced scenarios, like how to handle Store policies, how to manage multiple deployment assignments, etc.\n[Here](https://github.com/microsoft/react-native-code-push/blob/master/docs/api-js.md), instead, you can find an overview of the JavaScript APIs, with many details on how to customize the update experience.\nIf you're looking for an example with a C++ based host app, you can refer to [the official one](https://github.com/microsoft/react-native-code-push/tree/master/Examples/CodePushDemoApp). A C# version of the sample, instead, can be found [here](https://github.com/qmatteoq/CodePushSample).\n\nHappy coding!"
    },
    {
      "id": "/2021/03/16/64updates",
      "metadata": {
        "permalink": "/react-native-windows/blog/2021/03/16/64updates",
        "source": "@site/blog/2021-03-16-64updates.md",
        "title": "Gallery App, TurboModules, and more community modules",
        "description": "More modules and tools released in React Native 0.64",
        "date": "2021-03-16T00:00:00.000Z",
        "formattedDate": "March 16, 2021",
        "tags": [],
        "readingTime": 9.445,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Kiki Saintonge, Harini Kannan, Steven Moyes",
            "url": "https://twitter.com/ReactNativeMSFT"
          }
        ],
        "frontMatter": {
          "title": "Gallery App, TurboModules, and more community modules",
          "author": "Kiki Saintonge, Harini Kannan, Steven Moyes",
          "authorURL": "https://twitter.com/ReactNativeMSFT",
          "description": "More modules and tools released in React Native 0.64",
          "is_blog": true,
          "published_date": "March 16, 2021"
        },
        "prevItem": {
          "title": "Using CodePush in a React Native for Windows application",
          "permalink": "/react-native-windows/blog/2021/05/17/codepush"
        },
        "nextItem": {
          "title": "Windows & macOS version 0.63 updates, Hermes, and more",
          "permalink": "/react-native-windows/blog/2020/09/02/63updates"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/2021-03-16-64updates/\" />\n</head>\n\nReact Native 0.64 is out! Which means it's time to showcase all the work we've put in around supporting more community modules, TurboModules, APIs improvements, and even some tools, all in the effort to improve the developer experience.\n\n<!--truncate-->\n\nThere's been a lot of work on improving the developer experience, as that's been a focus for us as a whole across all our frameworks and platforms, and React Native for Windows is no exception! Through tooling, dogfooding our own work, and \"under the hood\" improvements, we're looking forward to sharing with you some of the highlights in this release that we're especially proud to announce.\n\n# 📣 React Native Gallery App\nAs part of our growing effort to improve the APIs, developer experience, and end-to-end story of developing React Native apps for Windows, we've decided to build and ship our own app, called the [React Native Gallery](https://github.com/microsoft/react-native-gallery).\n\nThe app's main purpose is to showcase all the current functionality available in React Native for Windows, while also being a way for us to test cross-platform community modules and keep ourselves honest about the process of pushing an app to the [Windows Store](https://www.microsoft.com/store/apps/windows).\n\n![rn-gallery-gif](assets/gallery_demo_1.gif)\n\nMuch like the [XAML Controls Gallery](https://www.microsoft.com/p/xaml-controls-gallery/9msvh128x2zt) for WinUI, we intend to have the React Native Gallery be available not only as a proving ground for our own work, but also a place where native and JavaScript components alike can be seen in action in the Windows ecosystem. This includes providing lightweight code snippets on each page for developers to copy out and use in their own scenarios.\n\n## 🧪 Try it out now!\nYou can install the app today! Get [React Native Gallery from the Microsoft Store](https://www.microsoft.com/store/productId/9NPG0B292H4R).\n\nAlternately, you can get the latest state of the app and the source to test things out directly on our [main repo branch](https://github.com/microsoft/react-native-gallery).\n\n# ✨ Developer Goodness\nAs with many of our releases, there's always a number of developer and \"under the covers\" upgrades we make to the framework as a whole. These usually includes things like performance improvements, better API parity and of course general bug fixes, but let's take a look at some of the notable items available this release.\n\n## 🎯 Easy opt-in to Hermes\n\nPerformance is a huge deal when developing in general, but especially so when it comes to using React Native.\n\n We're very invested in using Hermes and while there are teams using it in production, support is still experimental and we do not have the full Hermes debugger or Hermes in C# capabilities online yet. We would still love to know if you try Hermes and run into any issues, so go ahead and [give it a try today!](https://microsoft.github.io/react-native-windows/docs/hermes)\n\n To get starting using Hermes in a new project, pass the `--useHermes` flag when running the first `react-native-windows-init` command. Here are the full, first setup commands:\n\n - `npx react-native init <projectName> --template react-native@^0.64.0`\n - `cd <projectName>`\n - `npx react-native-windows-init --overwrite --useHermes`\n - `npx react-native run-windows`\n\n Have a pre-existing project you'd like to add Hermes to? You can still enable it, but will need to take a few extra steps to do it, but luckily, we've [got you covered for that too](https://microsoft.github.io/react-native-windows/docs/hermes#using-hermes-in-an-existing-project).\n\n## 🎉 API parity highlights\n\nMore component properties supported by the other platforms now work on Windows! Check them out.\n\n### ⚙ `Platform.version`\nThe `Platform` API's `version` functionality has now been extended to include detection for the release version you'd like to target.\n\n``` js\nimport { Platform } from 'react-native';\n\nif (Platform.Version >= 4) {\n  // We can use an API from UniversalApiContract 4\n} else {\n  // Fallback\n}\n```\n\nNot sure exactly which version you need? Check out our [documentation around SDK extensions](https://docs.microsoft.com/en-au/uwp/extension-sdks/device-families-overview) on Windows.\n\n[Learn more](https://microsoft.github.io/react-native-windows/docs/platform) about the `Platform` API through our documentation.\n\n### ⚙ More `Text` properties\nThe `Text` component properties `backgroundColor`, `border`, and `textTransform` are now available on Windows and apply to our native text controls as you'd expect.\n\n- **backgroundColor** will set the backfill/plate color behind your text.\n- **border** encompasses all the border functionalities, like borderWidth, borderColor, etc.\n- **textTransform** can force all strings lowercase, uppercase, or capitalization depending.\n\n```js\nimport React from \"react\";\nimport { Text, StyleSheet } from \"react-native\";\n\nconst TextTest = () => {\n  return (\n    <Text style={styles.newTextProperties}>\n      some text goes here\n    </Text>\n  );\n};\n\nconst styles = StyleSheet.create({\n  newTextProperties: {\n    color: \"white\",\n    backgroundColor: \"blue\",\n    borderColor: \"black\",\n    borderWidth: 1,\n    textTransform: \"capitalize\"\n  }\n});\n\nexport default TextTest;\n```\n\n### ⚙ `AccessibilityInfo`\nWe've begun improving the JavaScript and native control accessibility experiences by hooking up some initial behavior for these scenarios.\n\n- [**isReduceMotionEnabled**](https://reactnative.dev/docs/accessibilityinfo#isreducemotionenabled) returns true or false depending on whether the user of the device has specified they need less motion sensitivity - *full implementation*.\n- [**announceForAccessibility**](https://reactnative.dev/docs/accessibilityinfo#announceforaccessibility) tires to find an element on the current screen to raise the event from - *partial implementation*.\n- **isTouchExplorationEnabled** will return a boolean indicating whether or now the user has a screen narrator or similar running. This feature needs more testing, but is available in an alpha state for you to use - *partial implementation*.\n\n## 🎇 Expanded documentation\nWe've added a lot to our documentation too, both within the Native APIs and on other important developer topics like virtual machines and picking C or C++ to have your app created in.\n\n### 🔧🔨 Choice between C++ or C# compiled apps\nA big request for our documentation has been steps on how to set up an app for C++ or C# based development, and we're happy to announce that we've [put together all the info necessary](https://microsoft.github.io/react-native-windows/docs/native-code-language-choice) to get started with either.\n\n### 📡 Develop for Windows on anything\nIf you have either a local or Azure virtual machine set up, you can develop Windows app on a non-Windows PC.\n\nGrab the VM of your choice from the [Windows 10 development environment](https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/). Once you have that virtual environment up and running, set up that new VM [set up for React Native for Windows development](https://microsoft.github.io/react-native-windows/docs/rnw-dependencies) just as you would today and deploy your builds to it.\n\nCheck out the [full documentation on the process here](https://microsoft.github.io/react-native-windows/docs/win10-vm).\n\n### 💻 Native Windows APIs\nWe've even added a reference sheet so you can take a look at the native API's that are available under the [`Microsoft.ReactNative`](https://microsoft.github.io/react-native-windows/docs/Native-API-Reference) namespace, like:\n\n- [Enums](https://microsoft.github.io/react-native-windows/docs/Native-API-Reference#enums)\n- [Interfaces](https://microsoft.github.io/react-native-windows/docs/Native-API-Reference#interfaces)\n- [Structs](https://microsoft.github.io/react-native-windows/docs/Native-API-Reference#structs)\n- [Classes](https://microsoft.github.io/react-native-windows/docs/Native-API-Reference#classes)\n- [Delegates](https://microsoft.github.io/react-native-windows/docs/Native-API-Reference#delegates)\n\nCurious about how to work with native code using a React Native for Windows app? [We've got you covered for that too!](https://microsoft.github.io/react-native-windows/docs/native-code)\n\n## 🚀 TurboModules\n\nWe now have support for C++ JSI TurboModules using the same TurboModule interface that is available on Android and iOS. Since these APIs haven't been fully shipped or documented in React Native core yet, these APIs are subject to change.\n\nThis feature is still considered experimental in 0.64, because it is not finished in React Native Core.\n\n## 🎁 Get the goodness\nThe best way to upgrade from 0.62 or 0.63 to this latest **0.64** release is to:\n- Create a brand new blank 0.64 using `react-native-windows-init`\n- Copy over the content of your older versions project\n\nMoving forward we are looking to provide a diff tool to help make this easier, this tool would operate similarly to `react-native-upgrade-helper`.\n\nTo get the full list of release details, including breaking changes, check out our [release notes over on our repo.](https://github.com/microsoft/react-native-windows/releases/tag/react-native-windows_v0.64.0)\n\n# 📚 Growing Windows community module support\n\nOver the last couple of months, the team has made a concerted effort to increase the number of modules that target React Native for Windows. We know that modules are an important part of React Native ecosystem, so we are excited to share that we’ve added Windows implementations for several modules, including:\n\n- [react-native-tts](https://github.com/ak1394/react-native-tts)\n- [react-native-codepush](https://github.com/microsoft/react-native-code-push)\n- [react-native-sketch-canvas](https://github.com/creambyemute/react-native-sketch-canvas)\n- [react-native-pdf](https://github.com/wonday/react-native-pdf)\n- [react-native-print](https://github.com/christopherdro/react-native-print)\n- [react-native-device-info](https://github.com/react-native-device-info/react-native-device-info)\n- [react-native-orientation-locker](https://github.com/wonday/react-native-orientation-locker)\n- [rn-fetch-blob](https://github.com/joltup/rn-fetch-blob) ([module unmaintained](https://github.com/joltup/rn-fetch-blob/issues/666), but [Windows code in PR](https://github.com/joltup/rn-fetch-blob/pull/701))\n- [react-native-splash-screen](https://github.com/crazycodeboy/react-native-splash-screen) ([in PR](https://github.com/crazycodeboy/react-native-splash-screen/pull/514))\n- [react-native-fs](https://github.com/itinance/react-native-fs) ([in PR](https://github.com/itinance/react-native-fs/pull/952))\n\n… and more are coming! You can see which modules we’re tracking on the [Community Module Requests project board.](https://github.com/microsoft/react-native-windows/projects/23)\n\nIn addition to the modules that we have recently worked on, you can view and search the complete list of modules that work with Windows by visiting [reactnative.directory](https://reactnative.directory/). The directory catalogues modules that work on the major platforms including iOS, Android, Windows, and macOS and provides metrics around usage, popularity, and more.\n\nYou can also check out the [react-native-gallery repo](https://github.com/microsoft/react-native-gallery) to see some of the modules “in action”. We’re using the Gallery as a testbed to verify and showcase modules that work with Windows – we’re adding new samples over time, so check back often!\n\n## 🚧 A module I need doesn't work with Windows yet!\n\nFret not! We’re continually reassessing and reviewing the set of modules that are important to React Native for Windows devs, so if you need a module that doesn’t yet have a Windows implementation, please [open a new issue on the React Native for Windows GitHub repo.](https://github.com/microsoft/react-native-windows/issues/new/choose)\n\nIf you have experience writing Windows native code, you can also use the [new Community module template workflow](https://microsoft.github.io/react-native-windows/docs/native-modules-setup) to create a module template for Windows. This is a great way to start using native Windows APIs quickly in custom modules.\n\n## 🤝 Janea Systems\n![janea-logo](assets/janeasystemslogo.png)\n\nFinally, we wanted to highlight our partnership with [Janea Systems](http://www.janeasystems.com/), who has helped provide implementation, consultation, and support for many of the modules listed above. In particular, we wanted to shout out to [@jaimecbernardo](https://github.com/jaimecbernardo), [@joaocgreis](https://github.com/joaocgreis), and [@bzoz](https://github.com/bzoz) from Janea Systems for their help over the last few months.\n\n# Deprecations\n\n- **32-bit ARM is deprecated:**\n\nSome Windows IoT Core devices run 32-bit ARM processors. These devices are rare, and have not been tested with react-native-windows. We will be removing support for ARM32 in a future release. ARM64 remains supported.\n\n# Breaking changes\n\n- **Native module thread affinity**\n\n A bug was discovered which led to custom native modules often being invoked on the UI thread. This was unintentional and has been changed. We recognize that this may break existing modules in cases where affinity was relied upon without explicitly queuing to the UI thread. If you're affected by this or have a module that is, you can use the [`UIDispatcher` API](https://microsoft.github.io/react-native-windows/docs/ireactcontext-api#uidispatcher) to post to the UI thread.\n\n- `acceptsKeyboardFocus` **removed**\n\n In 0.63 we started warning on usage of `acceptsKeyboardFocus` that the property would be replaced by the built-in and type-safe focusable. In 0.64 we removed support from the property, redboxing if it is passed to a view and ignoring the property on touchables.\n\n- `AppTheme` **API reconciliation with Appearance**\n\n React Native 0.62 introduced Appearance and `useColorScheme` hooks to respond to changes in light/dark mode. This functionality supersedes several APIs in the react-native-windows specific `AppTheme` library. `AppTheme` functions that warned about removal in 0.63 are removed in 0.64. [See more here](https://microsoft.github.io/react-native-windows/docs/apptheme-api) on how to write components that adapt to theme.\n\n- `EmitJSEvent` **parameter passing**\n\n Calls to EmitJSEvent on the ReactContext previously wrapped the event object in a JavaScript array instead of passing it 1:1. This was fixed in 0.64, but any existing consumption of events fired by EmitJSEvent must be updated.\n\n- `ref.focus()` **focus visuals**\n\n Calling `focus()` on a component ref will now show native focus visuals by default. If you don't want focus visuals around your component, you can set the property `enableFocusRing={false}`.\n\n- **Synchronous native module returns**\n\n Native module methods marked as synchronous would previously have their results wrapped in an array. This is no longer the case."
    },
    {
      "id": "/2020/09/02/63updates",
      "metadata": {
        "permalink": "/react-native-windows/blog/2020/09/02/63updates",
        "source": "@site/blog/2020-09-02-63updates.md",
        "title": "Windows & macOS version 0.63 updates, Hermes, and more",
        "description": "React Native for Windows is now on a 0.63 stable release with React Native core, lighting up some fun new APIs",
        "date": "2020-09-02T00:00:00.000Z",
        "formattedDate": "September 2, 2020",
        "tags": [],
        "readingTime": 4.6,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Kiki Saintonge, Harini Kannan, Steven Moyes",
            "url": "https://twitter.com/ReactNativeMSFT"
          }
        ],
        "frontMatter": {
          "title": "Windows & macOS version 0.63 updates, Hermes, and more",
          "author": "Kiki Saintonge, Harini Kannan, Steven Moyes",
          "authorURL": "https://twitter.com/ReactNativeMSFT",
          "description": "React Native for Windows is now on a 0.63 stable release with React Native core, lighting up some fun new APIs",
          "is_blog": true,
          "published_date": "September 2, 2020"
        },
        "prevItem": {
          "title": "Gallery App, TurboModules, and more community modules",
          "permalink": "/react-native-windows/blog/2021/03/16/64updates"
        },
        "nextItem": {
          "title": "Fast refresh and more on Windows with 0.62 release",
          "permalink": "/react-native-windows/blog/2020/07/22/62updates"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/2020-09-02-rnw-63updates/\" />\n</head>\n\nReact Native for Windows is now on a [0.63](https://www.npmjs.com/package/react-native-windows) stable release with React Native core, lighting up some fun new APIs.\n\n<!--truncate-->\n\nBoth React Native for Windows and macOS have been bumped up a version - to 0.63 for Windows and 0.62 for macOS!\n\nThis means Windows is once again up-to-date with React Native core and following this new release we're lighting up a lot of new APIs and dev experiences that make developing on Windows using React Native that much better.\n\nCheck out the updated Getting Started guides for [Windows](https://microsoft.github.io/react-native-windows/docs/getting-started) and [macOS](https://microsoft.github.io/react-native-windows/docs/rnm-getting-started) to try out the new features for yourself!\n\nTo learn more about this release, API details, breaking changes, deprecations and more, [check out our release notes.](https://github.com/microsoft/react-native-windows/releases/tag/react-native-windows_v0.63.0)\n\n# Developer Experience Improvements\nReact Native Windows version 0.63 takes advantage of a few really great developer experience improvements that were added to the core React Native platform.\n\n\n## LogBox\n\n![logbox-windows](assets/logbox_demo.gif)\n\nLogBox is now on by default for React Native apps on Windows! This is a huge step forward in addressing some of the pain points experienced by developers when trying to debug their apps.\n\nWith this new update you can now more clearly read errors in a concise, formatted, and actionable layout that's easy on the eyes and the mind - a win-win!\n\nCheck out the [official blog post](https://reactnative.dev/blog/2020/07/06/version-0.63#logbox) for more information around this feature.\n\n## Autolinking\n\n![platformcolor-windows](assets/autolinking-windows.png)\n\nSometimes it really is the little things that make a huge difference and in this case Autolinking is no exception!\n\nNow when you install new modules and build your app we will automatically hook-up all those necessary native platform-specific code pieces for you in Windows. This will save you time and (possibly) a headache, if C++ isn't your strong suit.\n\nWe've also provided some new documentation around how to use [Autolinking with Native Modules](https://microsoft.github.io/react-native-windows/docs/native-modules-autolinking) in Windows.\n\n## PlatformColor\n\n![platformcolor-windows](assets/platformcolor_demo.gif)\n\n`PlatformColor` is a new API React Native core introduced that gives React Native app components the ability to leverage native system colors - meaning you can now subscribe to certain colors or brushes in your `StyleSheet` that respond to native platform actions like theme switching, user accent colors, or high contrast changes.\n\nHead over to the [official blog post](https://reactnative.dev/blog/2020/07/06/version-0.63#native-colors-platformcolor-dynamiccolorios) about this API to learn more about accessing native colors across all platforms, or check out our [new guidance documentation on PlatformColor](https://microsoft.github.io/react-native-windows/docs/windowsbrush-and-theme) to learn how to take advantage of Windows-specific colors and materials in your app.\n\n> Since the release of this API, the older Windows `AppTheme` API will be deprecated in favor of `PlatformColor`.\n\n## Pressable\n\n[Pressable](https://reactnative.dev/docs/pressable) is now available on React Native for Windows apps as well. This new core API helps make customizing your interaction experiences more robust and easier to fit around your custom components and scenario needs.\n\n## Community Modules\n\nAs with every big release, we're still working hard at adding Windows implementations to important community modules.\n\n\nCome check out what we've enabled for you this release!\n\n### react-navigation\n\n\n![reactnavigation-rnwindows](assets/react-nav.gif)\n\nOne of the more popular and much needed [react-navigation](https://github.com/react-navigation/react-navigation/tree/main/packages/native) module is now supported on Windows. Navigate between screens with native ease and preserve your stack history in this amazing community module.\n\n\n### react-native-checkbox\n\n\n![checkbox-rnwindows](https://raw.githubusercontent.com/react-native-community/react-native-checkbox/master/screenShots/demo-windows.png)\n\nThe community module [react-native-checkbox](https://github.com/react-native-community/react-native-checkbox) has also received Windows support this release. CheckBox is a rather unique native control for us and we're happy to have it in.\n\nSpecial shoutout and thank you to the [community members who helped make this possible!](https://github.com/react-native-community/react-native-checkbox/pull/68)\n\n## The Hermes Engine\n\n<img width=\"300\" height=\"300\" style=\"float: none; margin: -30px 4px 0;\" src=\"https://reactnative.dev/docs/assets/HermesLogo.svg\">\n\n[The Hermes Engine](https://hermesengine.dev/) is an open-source JavaScript engine that's been built to optimize the performance of React Native apps. It's currently opt-in for Android and macOS and we're in the process of bringing it to React Native Windows as well.\n\nIf you'd like to experiment with it in your Windows or macOS React Native apps, [head over to our guidance page](https://microsoft.github.io/react-native-windows/docs/hermes) to learn more about it.\n\n## What We've Been Doing\n\nSaying that working from home has taken some getting used to would be an understatement - it's been an incredible, eye-opening, stressful, and amazing adventure so far, obviously for many reasons both within and outside of work.\n\nHowever, that hasn't stopped us from trying to stay connected (virtually) with the passionate and awesome community that is React Native and cross-platform developers.\n\nCheck out some of the events we've done and will be doing:\n\n### React Wednesdays with digitalprimates\n\nIn mid August we connected with the folks over at [CodeItLive](https://www.twitch.tv/codeitlive) to talk about React Native on Windows and macOS.\n\nCheck out the recorded stream below or read all about it in their [blog post](https://www.digitalprimates.net/blog/react-wednesday-learn-about-react-native-for-windows-and-macos/).\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/1wk-Id0fgqE\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n### [React Native EU Virtual Edition](https://www.react-native.eu/)\n\n\nLooking a bit forward, check out the React Native EU conference hosted by Callstack, where our very own [Steven Moyes](https://twitter.com/moyessa) will be presenting about React Native for Desktops and Dual Screens.\n\n\nThis talk covers building React Native apps that target Windows, macOS, and the new Surface Duo device - [Check it out!](https://www.react-native.eu/)\n\n## Coming up next\n\nOn top of our continued quest to stay on the latest version of React Native core, there's a lot we're also looking into all the time on our [GitHub repo](https://github.com/microsoft/react-native-windows/) to help deliver the next best thing for you every release.\n\nFor APIs that includes things like flushing out mouse and keyboard support, experimenting more with Hermes on Windows, and of course adding Windows support to even more community modules, like [react-native-gesture-handler](https://github.com/software-mansion/react-native-gesture-handler), [react-native-svg](https://github.com/react-native-community/react-native-svg), [react-native-config](https://github.com/luggit/react-native-config), [and more!](https://github.com/microsoft/react-native-windows/issues?q=is%3Aopen+is%3Aissue+label%3AExtensions)"
    },
    {
      "id": "/2020/07/22/62updates",
      "metadata": {
        "permalink": "/react-native-windows/blog/2020/07/22/62updates",
        "source": "@site/blog/2020-07-22-62updates.md",
        "title": "Fast refresh and more on Windows with 0.62 release",
        "description": "React Native for Windows released latest stable 0.62.2 with Fast Refresh, RTL support, RedBox and thread safe property storage APIs",
        "date": "2020-07-22T00:00:00.000Z",
        "formattedDate": "July 22, 2020",
        "tags": [],
        "readingTime": 3.235,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Harini Kannan",
            "url": "https://twitter.com/ReactNativeMSFT"
          }
        ],
        "frontMatter": {
          "title": "Fast refresh and more on Windows with 0.62 release",
          "author": "Harini Kannan",
          "authorURL": "https://twitter.com/ReactNativeMSFT",
          "description": "React Native for Windows released latest stable 0.62.2 with Fast Refresh, RTL support, RedBox and thread safe property storage APIs",
          "is_blog": true,
          "published_date": "July 22, 2020"
        },
        "prevItem": {
          "title": "Windows & macOS version 0.63 updates, Hermes, and more",
          "permalink": "/react-native-windows/blog/2020/09/02/63updates"
        },
        "nextItem": {
          "title": "Build 2020 Recap",
          "permalink": "/react-native-windows/blog/2020/06/01/build2020recap"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/2020-07-22-rnw-62updates/\" />\n</head>\n\nReact Native for Windows released latest stable [0.62.2](https://www.npmjs.com/package/react-native-windows/v/0.62.2) with Fast Refresh, RTL support, RedBox and thread safe property storage APIs.\n\n<!--truncate-->\n\nAligning with our [releases strategy](https://microsoft.github.io/react-native-windows/docs/releases), we are happy to announce the general availability of stable latest [0.62.2 version](https://www.npmjs.com/package/react-native-windows/v/0.62.2) of React Native for Windows. You can try it out using our [Getting Started Instructions](https://microsoft.github.io/react-native-windows/docs/getting-started). Take a look at the [release notes](https://github.com/microsoft/react-native-windows/releases/tag/react-native-windows_v0.62.0) for highlights and breaking changes, more details below. A corresponding update for React Native for macOS is in progress.\n\n## Fast Refresh\nFast Refresh is a great developer productivity feature introduced in React Native in 0.61 as a new and improved version of \"hot reloading\" and \"live reloading\". Read more about this : [Fast Refresh in React Native](https://reactnative.dev/docs/fast-refresh). With 0.62, we have brought Fast Refresh to React Native for Windows:\n\n![fast-refresh-on-windows](assets/fastrefresh.gif)\n\n## Microsoft.ReactNative APIs\nSeveral updates have been made to provide thread safe, higher performance instance management on React Native for Windows through new Microsoft.ReactNative APIs. The deprecated ReactUwp framework is no longer supported with 0.62. Read our documentation on these for more, few highlights:\n* [ReactApplication](https://microsoft.github.io/react-native-windows/docs/reactapplication-api) : Base Application class for use in applications that are entirely written in react-native\n* [ReactNativeHost](https://microsoft.github.io/react-native-windows/docs/reactnativehost-api) : Entry point to create a new react-native instance\n* [ReactInstanceSettings](https://microsoft.github.io/react-native-windows/docs/reactinstancesettings-api) : Provides configuration of the react-native instance\n* [ReactContext](https://microsoft.github.io/react-native-windows/docs/ireactcontext-api) : Given to native modules to communicate with other native modules, views, application, and the react-native instance\n* [ReactPropertyBag](https://microsoft.github.io/react-native-windows/docs/ireactpropertybag-api) : Provides a thread-safe property storage\n* [XamlUIService](https://microsoft.github.io/react-native-windows/docs/xamluiservice-api) : Provides access to XAML UI specific functionality. See [Native UI components](https://microsoft.github.io/react-native-windows/docs/view-managers) for more details on the changes to `ViewManager` APIs.\n* [RedBoxHandler](https://microsoft.github.io/react-native-windows/docs/iredboxhandler-api) : Provides an extension point to allow custom error handling within the react-native instance\n\n## Alignment with core\nAs part of our ongoing alignment with React Native core we have added Windows support for several new APIs introduced in ReactNative 0.62. Few callouts here:\n   * [Appearance](https://reactnative.dev/docs/appearance) module is now supported on Windows. You can use this module to get information on the user's dark/light theme preferences and apply the right styling as needed. Windows previously had `AppTheme` APIs that are now deprecated in favor of aligning with React Native core. \n   * [focusable](https://reactnative.dev/docs/view#focusable) prop is now supported on `View` and `TextInput`. You can use this prop to indicate whether a component can be focusable (participate in tab order) when navigating with keyboard. Windows previously had an `acceptsKeyboardFocus` prop that is now deprecated in favor of aligning with React Native core. \n   * **RTL Support in Windows** : Windows now supports `forceRTL` and `allowRTL` modules. Auto-detect and applying RTL when app is running in RTL locale is in progress.\n\n![rtl](assets/rtl.gif)\n    \n## WinUI 3\nThe Windows UI Library ([WinUI](https://microsoft.github.io/microsoft-ui-xaml/)) is the native user experience (UX) framework for both Windows Desktop and UWP applications. WinUI is the path forward for all native Windows apps. React Native for Windows is layered on top of WinUI.\n\n[WinUI 3](https://docs.microsoft.com/en-us/windows/apps/winui/winui3/) is the next version of WinUI, completely decoupled from the [Windows 10 SDK](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk/) to enable faster shipping of UI features, more backward compatability and to simplify building of version adaptive apps. We are working in close alignment to add WinUI 3 support for React Native for Windows in order to ensure we are always tracking against the latest in native Windows platform. If you are curious, you can try out an experimental preview of this work using the optional flag `--useWinUI3` when running `react-native-windows-init`. You can read more about this effort [here](https://microsoft.github.io/react-native-windows/docs/winui3).\n\n## Coming up next\n\nWe will continue to keep up with React Native core versions: 0.63 upgrade for Windows is ongoing with a planned preview for August 2020. In addition, several updates are coming up for React Native for Windows core including support for [automatic linking of community modules](https://reactnative.dev/docs/linking-libraries-ios#automatic-linking) and [LogBox support](https://reactnative.dev/docs/debugging#logbox). \n\nWe are also continuing to add Windows support to key community modules, ongoing work includes [react-navigation](https://github.com/react-navigation/react-navigation), [react-native-slider](https://github.com/react-native-community/react-native-slider), [react-native-progressview](https://github.com/react-native-community/progress-view) and several others."
    },
    {
      "id": "/2020/06/01/build2020recap",
      "metadata": {
        "permalink": "/react-native-windows/blog/2020/06/01/build2020recap",
        "source": "@site/blog/2020-06-01-build2020recap.md",
        "title": "Build 2020 Recap",
        "description": "React Native for Desktop was a major topic at this year's Microsoft Build 2020 conference. Learn more about the sessions, takeaways, and key partnerships.",
        "date": "2020-06-01T00:00:00.000Z",
        "formattedDate": "June 1, 2020",
        "tags": [],
        "readingTime": 3.19,
        "hasTruncateMarker": false,
        "authors": [
          {
            "name": "Steven Moyes",
            "url": "http://twitter.com/moyessa"
          }
        ],
        "frontMatter": {
          "title": "Build 2020 Recap",
          "author": "Steven Moyes",
          "authorURL": "http://twitter.com/moyessa",
          "description": "React Native for Desktop was a major topic at this year's Microsoft Build 2020 conference. Learn more about the sessions, takeaways, and key partnerships.",
          "is_blog": true,
          "published_date": "June 10, 2020"
        },
        "prevItem": {
          "title": "Fast refresh and more on Windows with 0.62 release",
          "permalink": "/react-native-windows/blog/2020/07/22/62updates"
        },
        "nextItem": {
          "title": "Announcing React Native for macOS and more",
          "permalink": "/react-native-windows/blog/2020/05/19/rn4mupdadates"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/2020-06-01-build2020recap/\" />\n</head>\n\nAt the end of May 2020, Microsoft wrapped up the annual [Build developer conference](https://mybuild.microsoft.com/). React Native was a big theme at Build 2020 this year, with over 6 sessions dedicated to React Native and many tie-ins from other talks.\n\nThe biggest announcement from the team is that React Native for macOS is ready for general consumption! Although we announced this on [our blog](2020-05-19-rn4mupdadates.md) a few weeks ago, the team spent more time deep-diving into how folks can get started building apps for Windows and macOS.\n\nWe also announced several 1st and 3rd party applications that are taking advantage of React Native. For example, we showed how the Xbox (Beta) app for PC uses React Native for Windows to create great native experiences for gamers. Additionally, we announced that Facebook was using React Native for Windows and macOS to build Messenger Desktop. \n\n[![Gif of Xbox App](assets/build2020_xbox.gif)](https://www.microsoft.com/store/productId/9MV0B5HZVK9Z)\n\n## Key Takeaways\n\nThe team held 2 focus groups focused on cross-platform native app development, where the main goal was to understand motivotors, invesments, and challenges that people developing cross-platform applications faced. Below are some key takeaways from these focus groups and Q&A sessions:\n\n- Cross-platform developers are looking to share as much code as possible between mobile and desktop apps; however, developers do differentiate between mobile (iOS, Android) and desktop (Windows, macOS, Linux). \n\n- React Native continues to gain momentum and is seen as a viable stack due to familiaritiy with React and industry investment; this interest has become so prevalent that **enterprise companies are requesting solutions built with React Native by name.**\n\n- **Linux was a common target platform** for developers that are looking to target desktop. \n\n- Compared to Electron, native-based platforms like React Native were perceived favorably mainly **due to better performance.**\n\n- **Developers and designers prefer native apps**; platforms like Flutter are gaining in populatority, but not being native is seen as a negative. \n\n## Sessions\n\n### Skilling Session - \"Build cross platform apps that target Windows, Mac, and more!\"\n\nReact Native isn't just for building mobile apps! Come learn how you can use React Native to build truly native applications that target the entire family of Windows devices, Android, iOS, and Mac!\n\nView the session on [YouTube](https://www.youtube.com/watch?v=QMFbrHZnvvw).\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/QMFbrHZnvvw\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n### Live Interview - \"How PLEX is taking advantage of React Native\"\n\n[![Plex Interview](assets/build2020_plex.png)](https://mybuild.microsoft.com/sessions/b1306a79-b43b-43be-bd59-460b8db0c7a8)\n\nWith React Native for Windows Plex is able to write once and target a bunch of endpoints with a consistent user experience across each (Android, Windows and even Mac), RN leverages the platform capabilities and inputs that are native to that device. \n\nView the session on the [MyBuild website](https://mybuild.microsoft.com/sessions/b1306a79-b43b-43be-bd59-460b8db0c7a8).\n\n### Expert Q&A Session - \"Build Apps with React Native\"\n\n[![Expert Q and A](assets/build2020_expertqa.png)](https://mybuild.microsoft.com/sessions/d10c502e-325d-4c77-9471-462b37744db1)\n\nJoin the React Native team at Microsoft to learn more about building apps that target iOS, Android, Windows, and Mac. In this AMA-style experience, we answer your questions about building apps using React Native!\n\nView this session on the [MyBuild website](https://mybuild.microsoft.com/sessions/d10c502e-325d-4c77-9471-462b37744db1).\n\n### Unifying and evolving the Windows platform \n\n[![Evolving the Windows Platform](assets/build2020_evolvingwindowsplatform.png)](https://mybuild.microsoft.com/sessions/53ccd339-7cc0-4e66-bdb9-3eee6b270658)\n\nLearn how the Windows app platform is evolving and unifying Win32 and UWP so your present and future apps can easily target 1 billion+ Windows devices.\n\nView this session on the [MyBuild website](https://mybuild.microsoft.com/sessions/53ccd339-7cc0-4e66-bdb9-3eee6b270658).\n\n### Kevin Gallo's Q&A\n\n[![Kevin Q&A](assets/build2020_kevin.png)](https://mybuild.microsoft.com/sessions/cf5901a1-2cd2-4913-b4b7-f1af32db934a)\n\nJoin Kevin Gallo, corporate vice president of the developer platform for a live Q&A session to talk about the Windows announcements.\n\nView this session on the [MyBuild website](https://mybuild.microsoft.com/sessions/cf5901a1-2cd2-4913-b4b7-f1af32db934a).\n\n\n## What's next\n\nWe're excited to announce that the React Native at Microsoft team will be speaking at the React Native EU virtual conference in September! \n\nTo register, visit [react-native.eu](https://www.react-native.eu/).\n\n[![React Native EU Speaker Profile](assets\\build2020_reactnativeeu.png)](https://www.react-native.eu/)\n\nBeyond that, we're continuing to iterate and improve the React Native platform for all developers. Follow along on [GitHub](https://aka.ms/reactnative) and [Twitter](https://twitter.com/ReactNativeMSFT)!"
    },
    {
      "id": "/2020/05/19/rn4mupdadates",
      "metadata": {
        "permalink": "/react-native-windows/blog/2020/05/19/rn4mupdadates",
        "source": "@site/blog/2020-05-19-rn4mupdadates.md",
        "title": "Announcing React Native for macOS and more",
        "description": "We're on React Native core version 0.62 with new community modules, native module support across multiple platforms, and of course our official public release of React Native for macOS.",
        "date": "2020-05-19T00:00:00.000Z",
        "formattedDate": "May 19, 2020",
        "tags": [],
        "readingTime": 3.335,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Kiki Saintonge",
            "url": "http://twitter.com/KikiSaintonge"
          }
        ],
        "frontMatter": {
          "title": "Announcing React Native for macOS and more",
          "author": "Kiki Saintonge",
          "authorURL": "http://twitter.com/KikiSaintonge",
          "description": "We're on React Native core version 0.62 with new community modules, native module support across multiple platforms, and of course our official public release of React Native for macOS.",
          "is_blog": true,
          "published_date": "May 19, 2020"
        },
        "prevItem": {
          "title": "Build 2020 Recap",
          "permalink": "/react-native-windows/blog/2020/06/01/build2020recap"
        },
        "nextItem": {
          "title": "Keeping Up with React Native Core",
          "permalink": "/react-native-windows/blog/2020/02/01/0-m4updates"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/2020-05-19-rn4m-updates/\" />\n</head>\n\nWe're excited to announce our first preview release aligning with [React Native 0.62](https://reactnative.dev/blog/2020/03/26/version-0.62)!\n\n<!--truncate-->\n\nAs a preview release, we will try our best not to make breaking changes, but still have a few bumps to sort out before we're ready for release. You can now start trying out the [0.62-preview of React Native for Windows](https://www.npmjs.com/package/react-native-windows/v/0.62.0-preview.6)!\n\n A similar upgrade for [React Native for macOS is in progress](https://github.com/facebook/react-native/compare/master...microsoft:fb62merge). Stay tuned for the next update!\n\n## What's New?\n\n- New Features from React Native 0.62, like [`Appearance`](https://reactnative.dev/docs/appearance) and [`useColorScheme()`](https://reactnative.dev/docs/usecolorscheme) hooks\n- Visual Studio V142 build tools are now used\n-\tBetter RTL support\n-\tNew native module APIs (`REACT_INIT` and `REACT_FUNCTION`)\n-\tImproved diagnostics in command line tools\n-\tInitial ARM64 support\n-\tExperimental support for binary distribution of React Native Windows\n-\tBug fixes and reliability improvements\n\n## React Native for macOS\n\n![react-native-mac](assets/eloy_rn4m_preview_full.png)\n\nOne of our biggest announcements recently is our addition and full support of the [React Native for macOS](https://microsoft.github.io/react-native-windows/docs/rnm-getting-started) extension! We are super excited to be developing React Native support for macOS along side our Windows effort.\n\nWe have an official [npm package out for React Native for macOS](https://www.npmjs.com/package/react-native-macos) and a [repo available](https://github.com/microsoft/react-native-macos) to the public to follow and contribute to - we hope to see some really cool React Native apps out there in the future that can now truly run everywhere.\n\n## React Native on the Surface Duo\n\n![react-native-duo-emu](https://devblogs.microsoft.com/surface-duo/wp-content/uploads/sites/53/2020/04/reactnative-emulator-800.png)\n\nReact Native runs on the Surface Duo!\n\nThis is a little bit to be expected, as React Native works great today with Android, but just running on the new Surface Duo device isn't enough. We've also added support for awareness of the dual-screen device and its status through shipping two important APIs: **TwoPaneView** and **DeviceInfoModule**.\n\nTo learn more about developing on the Surface Duo with React Native, [go check out our latest blog post](https://devblogs.microsoft.com/surface-duo/build-react-native-apps-for-microsoft-surface-duo/) detailing the experience.\n\n## New Modules Supported!\n\nWe've begun addressing the Windows community module support gap - starting with contributions from us! This includes [**WebView**](https://github.com/react-native-community/react-native-webview) and [**Camera**](https://github.com/react-native-community/react-native-camera), [Picker](https://github.com/react-native-community/react-native-picker), [AsyncStorage](https://github.com/react-native-community/async-storage), [NetInfo](https://github.com/react-native-community/react-native-netinfo), and [DateTimePicker](https://github.com/react-native-community/datetimepicker).\n\nOn top of that initial set, we're also looking at a whole bunch more that we know are awesome and essential to have when building a React Native app. Check out the full list of what we're tracking and planning to tackle next on our [GitHub Project Board](https://github.com/microsoft/react-native-windows/projects/23).\n\nLastly, in addition to contributing to these community modules personally, we want to help bootstrap a robust test infrastructure and enhance reliability for consumers of these modules. We have started this process by adding CI to `react-native-webview` repo. Stay tuned for more!\n\n### WebView\n\n![react-native-webview-module](assets/final_demo_gif.gif)\n\nThe WebView module sets you up with the barebones web hosting tech that's available nativly on the device you're targetting. This module has been updated to support Windows and macOS.\n\n> To get your own version of the app in this short clip, check out the [RssReader sample](https://github.com/microsoft/react-native-windows-samples/tree/main/samples/rssreader).\n\n### Camera\n\n![react-native-camera-module](assets/react-camera.png)\n\nThe Camera module is another big step towards making it easier to give you unfettered access to native APIs.\n\nJust like on mobile, when you define a CameraFeed module, and the device you're running the app on has a camera attached, the component will hookup to the correct native APIs to give you access to the hardware needed to snap sweet pics.\n\n### Picker\n\n![react-native-picker-module](assets/picker-windows-module.png)\n\n### AsyncStorage\n\nArguably one of the most important modules to have available to you when building a React Native app, AsyncStorage is now fully supported on Windows and macOS.\n\n### NetInfo\n\nAn important network API for hooking up to and checking the health of your connection. As React Native is a JavaScript-based framework the need for an API such as this to be readily available on all platforms is very valuable - our recent release for this module supports both Windows and macOS.\n\n### DateTimePicker\n\n![react-native-datetimepicker-module](assets/windows_datetimepicker-module.png)\n\nA unique component that in many ways defines the design of the platform you're using, the DateTimePicker community control has been updated to support Windows as well now."
    },
    {
      "id": "/2020/02/01/0-m4updates",
      "metadata": {
        "permalink": "/react-native-windows/blog/2020/02/01/0-m4updates",
        "source": "@site/blog/2020-02-010-m4updates.md",
        "title": "Keeping Up with React Native Core",
        "description": "Announcing React Native for Windows v0.61, now on the high performance common core across iOS and Android",
        "date": "2020-02-01T00:00:00.000Z",
        "formattedDate": "February 1, 2020",
        "tags": [],
        "readingTime": 5,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Kiki Saintonge",
            "url": "http://twitter.com/KikiSaintonge"
          }
        ],
        "frontMatter": {
          "title": "Keeping Up with React Native Core",
          "author": "Kiki Saintonge",
          "authorURL": "http://twitter.com/KikiSaintonge",
          "description": "Announcing React Native for Windows v0.61, now on the high performance common core across iOS and Android",
          "is_blog": true,
          "published_date": "February 10, 2020"
        },
        "prevItem": {
          "title": "Announcing React Native for macOS and more",
          "permalink": "/react-native-windows/blog/2020/05/19/rn4mupdadates"
        },
        "nextItem": {
          "title": "Upgrading with Hermes Support and Automated Tests",
          "permalink": "/react-native-windows/blog/2019/12/3/m3updates"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/2020-02-10-m4updates/\" />\n</head>\n\nAnnouncing React Native for Windows v0.61, now on the high performance common core across iOS and Android!\n\n<!--truncate-->\n\nThis milestone is a huge one for us on the React Native for Windows team and we're super excited to officially announce that the work we have been doing in our C++ overhaul (formerly dubbed vnext) is now the new default framework installed when you integrate Windows into your React Native project.\n\nThe work in this latest release doesn't stop there though, check out all the other cool stuff we've released below!\n\n## We're on version 0.61\n\nThat's right! React Native for Windows is now fully up-to-date with React Native core's latest version - and we're planning to keep updated with their latest version with as little latency as possible.\n\nWe've updated the [Getting Started Guide](https://microsoft.github.io/react-native-windows/docs/getting-started) to reflect these changes and when you install the [ReactNative for Windows npmjs package](https://www.npmjs.com/package/react-native-windows) you will get these updates in that package.\n\n## Fewer steps to get started\n\nWith the convergence of vnext into our default React Native for Windows framework, you no longer need to specify a vnext template in the setup CLI steps.\n\nThis means after you [setup your React Native project](https://microsoft.github.io/react-native-windows/docs/getting-started), all you have to do is add our plugin:\n\n```\nyarn add rnpm-plugin-windows\n```\n\nAnd install the Windows extension:\n\n```\nreact-native windows\n```\n\nNow you're ready to start developing for Windows!\n\n## Our documentation is expanding\n\nIn addition to reducing the steps needed to get started **developing** in React Native for Windows - we're also expanding the docs to make it easier to access relevant information around **how to develop** for Windows using React Native.\n\nOne really big way we know we can help accelerate developers is through thorough and related documentation. That's why we've added two whole new sections this site:\n\n- [Versions](https://microsoft.github.io/react-native-windows/versions)\n  With versions we will now be tracking our release changelogs, older documentation so changes to certain APIs or components can be tracked, and stable versus latest releases so as a developer you can know exactly when to upgrade to ensure your app's performance and features are safe.\n- [APIs](https://microsoft.github.io/react-native-windows/docs/flyout-component)\n  The APIs section is now available to reference! All Windows and Mac API and Components will be listed there with a familiar layout to help you know which properties do what you need and what's available to you on the Windows and Mac components.\n\n**But wait, did you say Mac?**\n\nThat wasn't a typo!\n\nWe've actually begun investing in [React Native for Mac](https://www.aka.ms/react-native-mac). Although this progress is still in its early stages, a lot of the functionality and features we implemented for Windows are also shared on the Mac, so this gives us a nice head start here and is one of the many reasons we decided to undertake this effort.\n\nYou may also notice that we've added Mac to the this site and as we expand in the React Native for Mac area, we will continue to add documentation and support for developers right here.\n\n## Improved performance\n\nA large improvement to performance happened in this last release that had to due with our threading model. You might have also heard us calling this the \"confident instancing programming model\".\n\nWhat we did was update the host and instance infrastructure in React Native for Windows to have a more robust and consistent threading model. While this change helps increase thread stability today, it will also enable us to support more complex scenarios like hosting multiple RN instances within the same app in the future.\n\n## SVG Image support\n\nAs of this latest release we now natively support svg files. No separate component or module is needed - just simply use the Image component in your React Native app and when you target Windows your svg files will be loaded and used just as they should.\n\n## Coming up next\n\n![Roadmap_M1_Future](assets/m1-5roadmap_m4release.png)\n\nIf you're curious about our immediate and future plans, feel free to check out our [milestone progress on our repo](https://github.com/microsoft/react-native-windows/milestones), but there are also some other cool things to get excited about that we'll be focusing on between now and April 2020. Check them out below!\n\n### February\n\n- **Dual-screen support**\n\n  We're bringing [TwoPaneView](https://docs.microsoft.com/en-us/uwp/api/microsoft.ui.xaml.controls.twopaneview?view=winui-2.2) to React Native for Windows as a component! This means React Native developers will have the ability to be easily conscious of when their app is displaying on one of the screens or expanding across both - with the API automatically adjusting for the hinge seam allowance in the center - so no app information is lost.\n\n  You can participate in the conversation on these modules here: [TwoPaneView](https://github.com/react-native-community/discussions-and-proposals/issues/197) and [ExtendedDeviceInfo](https://github.com/react-native-community/discussions-and-proposals/issues/189)\n\n- **API parity**\n  We are investing in tooling to comprehensively measure API parity of react-native-windows with all react-native APIs. This will help set us up for complete API parity in March and April milestones to follow.\n\n- **Community modules updates to support Windows**\n\n  We know that community modules and extensions are an important part of building a great React Native app. We’re currently working on adding support to **react-native-video** and will be starting work on migrating **Picker** and **WebView** modules to the corresponding community repos in February.\n\n  A lot more are planned for future months, you can find the native modules on our radar on this [project board](https://github.com/microsoft/react-native-windows/projects/23).\n\n  Feel free to file issues if there are more you would like to see Windows add support for.\n  For getting starting building native modules, [the guide can be found here](https://microsoft.github.io/react-native-windows/docs/native-modules).\n\n- **Upgrade helper**\n- **Alleviate disk space issues with CI**\n\n### March\n\n- [Turbo Modules](https://github.com/react-native-community/discussions-and-proposals/blob/master/proposals/0002-Turbo-Modules.md )\n- Lottie\n- Upgrade to 0.62\n- API completion (Accessibility, View Style)\n- Integration with react-native init\n- Integration with Facebook documentation\n- Turbo Modules investigation\n- Transition keyboard changes into RN core\n\n### April\n\n- AsyncStorage/FS modules\n- Helix for downlevel testing\n- API completion (TouchableWithoutFeedback, AppState, LayoutAnimatoin, ScrollView)\n- Keyboarding improvements (autofocus, focus lost, tabbing, etc.)\n- Community module directory\n- VSCode integration, TypeScript, direct debugging, Windows config\n- Targetting WinUI 3.0"
    },
    {
      "id": "/2019/12/3/m3updates",
      "metadata": {
        "permalink": "/react-native-windows/blog/2019/12/3/m3updates",
        "source": "@site/blog/2019-12-3-m3updates.md",
        "title": "Upgrading with Hermes Support and Automated Tests",
        "description": "New features and other updates upon Milestone 3 completion",
        "date": "2019-12-03T00:00:00.000Z",
        "formattedDate": "December 3, 2019",
        "tags": [],
        "readingTime": 3.775,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "React Native at Microsoft",
            "url": "http://twitter.com/reactnativemsft"
          }
        ],
        "frontMatter": {
          "title": "Upgrading with Hermes Support and Automated Tests",
          "author": "React Native at Microsoft",
          "authorURL": "http://twitter.com/reactnativemsft",
          "description": "New features and other updates upon Milestone 3 completion",
          "is_blog": true,
          "published_date": "December 3, 2019"
        },
        "prevItem": {
          "title": "Keeping Up with React Native Core",
          "permalink": "/react-native-windows/blog/2020/02/01/0-m4updates"
        },
        "nextItem": {
          "title": "Roadmap for vnext",
          "permalink": "/react-native-windows/blog/2019/07/22/roadmap"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/2019-12-03-m3updates/\" />\n</head>\n\nWe wrapped up [Milestone 3](https://github.com/microsoft/react-native-windows/milestone/17) a month ago which included **upgrade to support React Native version 0.60, Native extensions developer story, integration with the new high performance JS engine- Hermes, E2E test infrastructure and a host of added API support**. Some detailed highlights from the past few months are shared below.\n\n<!--truncate-->\n\nYou can get some of the latest on *what's new with React Native for Windows* from the [breakout session](https://myignite.techcommunity.microsoft.com/sessions/81326) and [Channel9 interview](https://myignite.techcommunity.microsoft.com/sessions/89307) from IGNITE 2019.\n\n## Upgrade to version 0.60\n\nKeeping up with React Native versioning, we completed the upgrade for react-native-windows vNext from 0.59 to 0.60. You can now develop for RN 0.60 and target Windows.\n\n```\nreact-native init <project name> --version 0.60.6\n```\n\nSee [Getting Started Guide for vNext](https://microsoft.github.io/react-native-windows/docs/getting-started) for more details.\n\n## Support for Hermes\n[Hermes](https://github.com/facebook/hermes) is a new JavaScript engine introduced by Facebook optimized for fast startup of React Native apps. We are happy to share that React Native for Windows vnext also supports Hermes as a build option with v0.60 and initial tests with a handful of Microsoft apps have shown high performance gains in both memory and startup time (boot latency reduced ~100-400ms) using the same.\n \nYou can turn on Hermes for your apps by setting the msbuild property `USE_HERMES` in `vnext\\PropertySheets\\React.Cpp.Props` to `true`.\n\n## E2E automated tests and infrastructure\n\nWe bootstrapped E2E test infrastructure using Appium (WinAppDriver) and we now have several automated E2E tests running as part of the code-commit pipeline for more reliability. Go [here](https://microsoft.github.io/react-native-windows/docs/e2e-test) to learn more.\n\n## Native extensions developer story\n\nYou can now begin authoring and consuming standalone Native Modules and custom View Managers through React Native for Windows vNext. We have enabled the infrastructure to extend and add support to external packages and community modules similar to what you can do today for accessing iOS/Android APIs. Check out our docs on these topics :\n* [Native modules](https://microsoft.github.io/react-native-windows/docs/native-modules)\n* [Native UI components](https://microsoft.github.io/react-native-windows/docs/view-managers)\n* [Native modules advanced](https://microsoft.github.io/react-native-windows/docs/native-modules-advanced)\n* [Authoring standalone native modules](https://microsoft.github.io/react-native-windows/docs/native-modules-setup)\n\nWhile working on this, we have identified several performance and developer experience improvements to instance creation and management. These updates will start to trickle in the upcoming [Milestone 4](https://github.com/microsoft/react-native-windows/milestone/18). We are simultaneously sharing these proposals with Facebook to ensure react-native for iOS, Android and Mac can also benefit from these improvements.\n\nWith the infrastructure now in place, we have begun bootstrapping a handful of community module repos with support for React Native for Windows vNext. As we make progress, we intend to formalize the developer experience, tooling, tests more and publish guidance around the same. You can keep track of our backlog through the [Community Modules Project](https://github.com/microsoft/react-native-windows/projects/23).\n\n## APIs and new feature updates\nCore components and modules are almost fully supported, see updates to [Parity Status](https://microsoft.github.io/react-native-windows/docs/parity-status) for details. Completed APIs includes `Switch`, `Text`, `FlatList`, `TextInput` (excluding few props that need underlying platform work) components as well as `Keyboard`, `Alert` modules and more. We are making steady progress on others like `Accessibility`, `Image`, `Animations` (useNativeDriver), `View` border properties etc.,\n \nIn addition to supporting the [newly added APIs for Accessibility in React Native v0.60](https://facebook.github.io/react-native/blog/2019/07/03/version-60#focus-on-accessibility), we have also introduced a couple of **new APIs for better accessibility in lists**, taking some of the best practices from Windows and giving back to the React Native community.  You can read more about the proposal [here](https://github.com/react-native-community/discussions-and-proposals/pull/146), this has been implemented in react-native-windows.\n \nYou can now access signature Windows themes and Fluent Design visuals like Acrylic and Reveal from React Native for Windows – Read [Windows Brushes and Themes](https://microsoft.github.io/react-native-windows/docs/windowsbrush-and-theme) for more details. In addition, we have improved several built in keyboard focus behaviors and added a few APIs in this area as well.\n\n## Coming up next\n\nYou can take a peek at the [upcoming Milestones](https://github.com/microsoft/react-native-windows/milestones) with a backlog lining up through Summer 2020. The immediate next Milestone we are working on is due by January 2020 with these high priority objectives:\n   * Upgrade to RN v 0.61\n\t* React Native for Windows vnext becomes mainline and fully replaces React Native for Windows current as the default. Work left to accomplish this includes 90% complete API parity on lean-core APIs (pending updates needed in underlying native platform), completion of Native extensions host instantiation APIs and developer experiences and other known breaking changes.\n\t* Add support to key community modules like Camera, Video, Lottie and few others that have been requested by customers.\n\t* Setup infrastructure for consuming WinUI 2.2 nuget package for wrapping high value components/modules and setup for future WinUI dependencies\n   * Begin support for dual screen scenarios"
    },
    {
      "id": "/2019/07/22/roadmap",
      "metadata": {
        "permalink": "/react-native-windows/blog/2019/07/22/roadmap",
        "source": "@site/blog/2019-07-22-roadmap.md",
        "title": "Roadmap for vnext",
        "description": "A prospective roadmap for React Native for Windows vnext project (2019 through early 2020)",
        "date": "2019-07-22T00:00:00.000Z",
        "formattedDate": "July 22, 2019",
        "tags": [],
        "readingTime": 1.41,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "React Native at Microsoft",
            "url": "http://twitter.com/reactnativemsft"
          }
        ],
        "frontMatter": {
          "title": "Roadmap for vnext",
          "author": "React Native at Microsoft",
          "authorURL": "http://twitter.com/reactnativemsft",
          "description": "A prospective roadmap for React Native for Windows vnext project (2019 through early 2020)",
          "is_blog": true,
          "published_date": "July 22, 2019"
        },
        "prevItem": {
          "title": "Upgrading with Hermes Support and Automated Tests",
          "permalink": "/react-native-windows/blog/2019/12/3/m3updates"
        },
        "nextItem": {
          "title": "July 2019 Updates",
          "permalink": "/react-native-windows/blog/2019/07/21/updates"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/2019-07-22-rnw-roadmap/\" />\n</head>\n\nThis document outlines some context and prospective roadmap for React Native for Windows. This project is under active development by the Microsoft Developer Platform team in collaboration with Office, Xbox and other partners as well as the wider React Native community. This roadmap is not meant to be exhaustive or guaranteed since we are also keeping up with the evolving [facebook\\react-native](http://facebook.github.io/react-native/) project and the needs of the React Native community.\n\n<!--truncate-->\n\nThis repo contains 2 parallel implementations of React Native for Windows:\n\n## current\n\nThe [\"current\"](https://github.com/microsoft/react-native-windows/tree/0.60-stable/current) subdirectory holds an earlier C# implementation for `react-native-windows` that has existed since 2016. This architecture is strictly in maintenance mode and investments here are limited to upgrading of versions to support latest react-native versions and addressing any blocking issues/bugs to make sure existing customers of this implementation can upgrade their apps.\n\nPlease continue to report issues as you encounter them, but be sure to use the [correct template](https://github.com/microsoft/react-native-windows/issues/new?assignees=rozele&labels=.NET&template=DOTNET.md) for issues related to the existing `react-native-windows` package.\n\n## vnext\n\nThe [\"vnext\"](https://github.com/microsoft/react-native-windows/tree/main/vnext) subdirectory holds the newer, high performance implementation for `react-native-windows` written in C++ to better align with the shared C++ react-native core as it evolves. This is the new architecture where all the ongoing feature investments are being made at this time. You can read more about this effort [here](https://github.com/microsoft/react-native-windows/tree/main/README.md).\n\nOur intent is to provide a compatibility layer for vnext that will support existing apps, view managers, and native modules written in C# with minimal breaking changes.\n\nWe are tracking progress across several workstreams on this vnext effort through [Projects](https://github.com/microsoft/react-native-windows/projects), [Issues](https://github.com/microsoft/react-native-windows/issues?q=is%3Aopen+is%3Aissue+label%3Avnext) and [Milestones](https://github.com/microsoft/react-native-windows/milestones).\n\nThe below picture captures the high level roadmap for investments through 2019 and into early 2020.\n\n![Roadmap](assets/roadmap.png)"
    },
    {
      "id": "/2019/07/21/updates",
      "metadata": {
        "permalink": "/react-native-windows/blog/2019/07/21/updates",
        "source": "@site/blog/2019-07-21-updates.md",
        "title": "July 2019 Updates",
        "description": "New features and other updates upon Milestone 2 completion",
        "date": "2019-07-21T00:00:00.000Z",
        "formattedDate": "July 21, 2019",
        "tags": [],
        "readingTime": 3.715,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "React Native at Microsoft",
            "url": "http://twitter.com/reactnativemsft"
          }
        ],
        "frontMatter": {
          "title": "July 2019 Updates",
          "author": "React Native at Microsoft",
          "authorURL": "http://twitter.com/reactnativemsft",
          "description": "New features and other updates upon Milestone 2 completion",
          "is_blog": true,
          "published_date": "July 21, 2019"
        },
        "prevItem": {
          "title": "Roadmap for vnext",
          "permalink": "/react-native-windows/blog/2019/07/22/roadmap"
        }
      },
      "content": "<head>\n  <meta http-equiv=\"Refresh\" content=\"0; URL=https://devblogs.microsoft.com/react-native/2019-07-21-rnw-updates/\" />\n</head>\n\nOver the past couple of months and spread across several contributors from Microsoft, we have completed [Milestone 2](https://github.com/microsoft/react-native-windows/milestone/16) for React Native for Windows. This blog post covers the highlights of the release.\n\n<!--truncate-->\n\n## Upgrade to support RN version 0.59\n\nBoth the `current` and `vnext` implementations of `react-native-windows` have been upgraded to support [React Native version 0.59](https://facebook.github.io/react-native/blog/2019/03/12/releasing-react-native-059). With this, you should be able to use the [React Hooks](https://reactjs.org/docs/hooks-intro.html) and all other goodness from the RN v0.59 update while targeting React Native for Windows.\n\n_**Note**: You will need to explicitly specify the RN version number while initializing your project using the CLI to target React Native for Windows vnext like so_:\n\n```\nreact-native init <project name> --version 0.59.10\n```\n\n\tRead the updated [Getting Started Guide for vNext](https://github.com/microsoft/react-native-windows/blob/main/vnext) for more details.\n\n## Updates to parity in high priority APIs\n\nWe are making steady progress in achieving parity of implementation of React Native APIs in alignment with the React Native [Lean Core effort](https://github.com/facebook/react-native/issues/23313). As part of Milestone 2 - we have completed implementations of all the P1 (must-have) APIs on lean core components such as `Text`, `TextInput`, `View`, `Image`, `ScrollView`, `FlatList` and `Switch` as well as modules such as `Accessibility`, `LayoutProps`, smooth animations using native drivers, animated transforms etc.,\n\n![Animated Transforms](assets/transforms.gif)\n\nWe are making steady progress in this workstream and will be investing more in [Milestone 3](https://github.com/microsoft/react-native-windows/milestone/17) with a goal to get to complete feature parity on lean-core components before EOY 2019. You can keep track of the progress here through the [Core Feature Parity project](https://github.com/microsoft/react-native-windows/projects/7) and [Parity Status doc](../../docs/parity-status.md). We will also be working towards moving non lean-core components into a separate package in the upcoming months.\n\n## NEW Features!\n\nWe have introduced several new features, including:\n\n1.  **Keyboarding APIs** to enable keyboard and gamepad invocation scenarios with good default behaviors for JS components like `Button`. See [Proposal draft](https://github.com/ReactWindows/discussions-and-proposals/blob/harinikmsft-keyboardapis/proposals/0000-keyboard-apis.md) for more details.\n\n_Example usage:_\n\n```\n<View onKeyDown={this._onKeyDown} />\n\nprivate _onKeyDown = (event: IKeyboardEvent) => {\n   this.setState({ lastKeyDown: event.nativeEvent.key });\n};\n\n```\n\n2.  New APIs for **handling theming and high contrast** scenarios through styles. See [Proposal comment](https://github.com/react-native-community/discussions-and-proposals/issues/126#issuecomment-500561803) for details.\n\n_Example usage:_\n\n```\ncomponentDidMount() {\n  AppThemeState.currentTheme.addListener('themechanged', this.onAppThemeChanged);\n}\n\nonAppThemeChanged = (event) => {\n  /*Logic on theme changed goes here*/\n  this.setState({appThemeState: AppThemeState.currentTheme});\n}\n\n/* In render function */\n<TextInput\n   style={[styles.inputStyle, this.state.appThemeState.currentTheme == 'dark' ? styles.darkInput : styles.lightInput]}\n</TextInput>\n```\n\n3.  New APIs for **better accessibility in lists**. See [Proposal](https://github.com/react-native-community/discussions-and-proposals/pull/146) for detailed documentation.\n\n_Example usage:_\n\n```\n<FlatList data={this.state.listdata}\n accessibilityRole=\"list\"\n renderItem={({item}) =>\n  <View accessibilityRole=\"listItem\"\n        accessibilitySetSize ={this.state.listdata.count}\n        accessibilityPostInSet={item.id} >\n     <Text>{item.name}</Text>\n  </View>}\n</FlatList>\n```\n\nThis marks the beginning of a journey where we actively will be contributing back to React Native and the wider community as almost all these APIs have been designed to be platform neutral/aligned with React programming model with a view to enhance the overall React Native API story for desktop and other targets. You can read about and participate in our proposals process [here](https://github.com/microsoft/react-native-windows/tree/main/vnext/proposals).\n\nWe are working on better documentation and samples for these new updates, stay tuned!\n\n## Onboarding and developer experience\n\nWe have been steadily addressing onboarding issues with the CLI, VS 2019 toolchain etc., to ensure reliability of your development experience - **you can use VS 2019** to build React Native for Windows vNext projects. Thank you to those who have spun the wheels on this project so far and filed issues, please continue to report issues as you see them.\n\nWe are also happy to report that we have begun a collaboration with VS Code for adding [React Native extension](https://marketplace.visualstudio.com/items?itemName=msjsdiag.vscode-react-native) support for React Native Windows. Through this extension, you will be able to debug your JS directly in VS Code without needing the Chrome debugger and several other useful tooling (including intellisense). We are in the early stages here, but since the work is happening in OSS, you can start trying this out using [these instructions](https://github.com/microsoft/react-native-windows/wiki/VS-Code-Debugging).\n\n![VSCode JS Debugging](assets/vscode.png)\n\n## Coming up next\n\nWe are tracking the next set of work for React Native for Windows through [Milestone 3](https://github.com/microsoft/react-native-windows/milestone/17) targeting a Fall 2019 ETA. The broad themes for Milestone 3 are:\n\n- Upgrade to RN v0.60\n- Complete feature parity for all “lean-core” RN APIs\n- Native extensions developer story\n- More new features around mouse hover, styling JS components, custom tab navigation, directional focus etc.,\n- Improved developer experience, documentation and onboarding reliability\n- Strategic performance investments and test infrastructure bring up\n- React-Native-Windows targeting [WinUI 3.0](https://github.com/microsoft/microsoft-ui-xaml/blob/master/docs/roadmap.md#winui-3-q4-2019---2020).\n\nPlease see the [Roadmap 2019](./2019-07-22-roadmap.md) blog for more details."
    }
  ]
}